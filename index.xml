<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I&#39;m company</title>
    <link>http://blog.imcompany.cn/</link>
    <description>Recent content on I&#39;m company</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 01 Jul 2019 07:04:09 +0800</lastBuildDate>
    
        <atom:link href="http://blog.imcompany.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Apollo Client自定义问题拾遗</title>
      <link>http://blog.imcompany.cn/post/apollo-client-custom/</link>
      <pubDate>Mon, 01 Jul 2019 07:04:09 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/apollo-client-custom/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;由于公司很多服务要接入Apollo配置中心，并且对于项目的接入有网络要求，根据&lt;a href=&#34;https://github.com/ctripcorp/apollo/wiki/Java%25E5%25AE%25A2%25E6%2588%25B7%25E7%25AB%25AF%25E4%25BD%25BF%25E7%2594%25A8%25E6%258C%2587%25E5%258D%2597#1221-%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589apollo-meta-server%25E5%259C%25B0%25E5%259D%2580%25E5%25AE%259A%25E4%25BD%258D%25E9%2580%25BB%25E8%25BE%2591&#34;&gt;官方说明&lt;/a&gt;，需要自定义Client来完成&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;接入步骤&#34;&gt;接入步骤&lt;/h2&gt;

&lt;h3 id=&#34;新建maven项目&#34;&gt;新建maven项目&lt;/h3&gt;

&lt;p&gt;在Idea中新建maven项目，基于quickstart构建&lt;/p&gt;

&lt;h3 id=&#34;增加项目依赖&#34;&gt;增加项目依赖&lt;/h3&gt;

&lt;p&gt;官方说明的建议在新的client中依赖Apollo官方的client，再根据业务进行扩展，所以maven依赖apollo-client，公司项目的网络访问需要通过L5来进行，所以还要依赖L5的jar，目前这个jar包没有maven坐标，只能以lib方式引入&lt;/p&gt;

&lt;h3 id=&#34;自定义metaserver&#34;&gt;自定义MetaServer&lt;/h3&gt;

&lt;p&gt;关键的部分，自定义满足公司网络条件的MetaServer，Apollo官网说明是实现MetaServerProvider且Order值小的Providor被使用，按照说明进行实现&lt;/p&gt;

&lt;h3 id=&#34;maven打包client&#34;&gt;Maven打包Client&lt;/h3&gt;

&lt;p&gt;执行
&lt;strong&gt;mvn clean install&lt;/strong&gt;
进行打包，解压jar包发现就只有一个Providor的实现类，这样jar运行有问题。需要把新Client所有的依赖都打进jar包，在网上找了半天，需要在POM中增加maven的plugin的配置，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nxml&#34;&gt;&amp;lt;!-- 打包所有的maven依赖到jar包 --&amp;gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.1&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;artifactSet&amp;gt;
                    &amp;lt;excludes&amp;gt;
                        &amp;lt;exclude&amp;gt;junit:junit&amp;lt;/exclude&amp;gt;
                    &amp;lt;/excludes&amp;gt;
                &amp;lt;/artifactSet&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nxml&#34;&gt;&amp;lt;!-- 添加依赖的非maven jar包 --&amp;gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;com.googlecode.addjars-maven-plugin&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;addjars-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.5&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;add-jars&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;resources&amp;gt;
                    &amp;lt;resource&amp;gt;
                        &amp;lt;directory&amp;gt;${basedir}/lib&amp;lt;/directory&amp;gt;
                    &amp;lt;/resource&amp;gt;
                &amp;lt;/resources&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于项目中使用了maven依赖与非maven依赖，所以上述的两个插件都要使用。增加了上面两个插件后再运行打包命令查看生成的jar就发现所有的依赖都在jar中了。&lt;/p&gt;

&lt;h3 id=&#34;项目中使用client&#34;&gt;项目中使用Client&lt;/h3&gt;

&lt;p&gt;选择一个项目在测试环境进行配置调试，自定义的Meta Server一直没有生效，所以查找&lt;a href=&#34;https://github.com/ctripcorp/apollo/issues/1472&#34;&gt;官方文档&lt;/a&gt;，由于自定义Providor是通过&lt;a href=&#34;https://blog.csdn.net/comkingfly/article/details/7645245?utm_source=tuicool&amp;amp;utm_medium=referral&#34;&gt;SPI&lt;/a&gt;方式实现的，所以正确的实现方式是新建resource文件夹，指定MetaServerProvider的真正实现类的带包名类才可以，哎，找了我好久。&lt;/p&gt;

&lt;h3 id=&#34;后续操作&#34;&gt;后续操作&lt;/h3&gt;

&lt;p&gt;后续会把client上传到内部maven仓库，完善配置API，使业务方可以零配置来使用配置中心。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Maven的打包机制还是不清晰，处理打包问题费了很多时间，要好好重新学习一下&lt;/li&gt;
&lt;li&gt;Apollo的官方文档还需要再仔细阅读，有问题多查issue，因为可能有人已经遇到了&lt;/li&gt;
&lt;li&gt;多读读源码，真正的体会大牛的软件设计思想&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Apollo 配置中心畅游</title>
      <link>http://blog.imcompany.cn/post/apollo-config-swim/</link>
      <pubDate>Thu, 09 May 2019 17:34:09 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/apollo-config-swim/</guid>
      
        <description>

&lt;h2 id=&#34;目前市面上的开源产品&#34;&gt;目前市面上的开源产品&lt;/h2&gt;

&lt;h3 id=&#34;disconf&#34;&gt;&lt;a href=&#34;https://github.com/knightliao/disconf&#34;&gt;Disconf&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2014年7月百度开源的配置管理中心，同样具备配置的管理能力，目前已经不维护了，最近的一次代码提交是两年前了。&lt;/p&gt;

&lt;h3 id=&#34;spring-cloud-config&#34;&gt;&lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-config&#34;&gt;Spring Cloud Config&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2014年9月开源，Spring Cloud生态组件，与Spring Cloud体系无缝整合。&lt;/p&gt;

&lt;h3 id=&#34;apollo&#34;&gt;&lt;a href=&#34;https://github.com/ctripcorp/apollo&#34;&gt;Apollo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2016年5月，携程框架部开源的配置管理中心，具备规范的权限、流程治理等特性。&lt;/p&gt;

&lt;h3 id=&#34;nacos&#34;&gt;&lt;a href=&#34;https://github.com/alibaba/nacos&#34;&gt;Nacos&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2018年6月，阿里开源的配置中心，可以做DNS和RPC的服务发现。&lt;/p&gt;

&lt;h2 id=&#34;为什么选择apollo&#34;&gt;为什么选择Apollo&lt;/h2&gt;

&lt;h3 id=&#34;社区活跃&#34;&gt;社区活跃&lt;/h3&gt;

&lt;p&gt;刚刚发布了&lt;a href=&#34;https://github.com/ctripcorp/apollo/releases/tag/v1.4.0&#34;&gt;1.4.0&lt;/a&gt;版本，Issue处理速度快&lt;/p&gt;

&lt;h3 id=&#34;文档齐全&#34;&gt;文档齐全&lt;/h3&gt;

&lt;p&gt;体验，部署，设计文档都齐全&lt;/p&gt;

&lt;h3 id=&#34;重要的灰度发布&#34;&gt;重要的灰度发布&lt;/h3&gt;

&lt;p&gt;想发布一台机器试试水，可以！&lt;/p&gt;

&lt;h3 id=&#34;开源协议友好&#34;&gt;开源协议友好&lt;/h3&gt;

&lt;p&gt;Apache 2 license&lt;/p&gt;

&lt;h2 id=&#34;apollo都有哪些重要功能&#34;&gt;Apollo都有哪些重要功能&lt;/h2&gt;

&lt;p&gt;以下摘自&lt;a href=&#34;https://github.com/ctripcorp/apollo#features&#34;&gt;官网说明&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;统一管理不同环境-不同集群的配置&#34;&gt;统一管理不同环境、不同集群的配置&lt;/h3&gt;

&lt;h3 id=&#34;配置修改实时生效-热发布&#34;&gt;配置修改实时生效（热发布）&lt;/h3&gt;

&lt;h3 id=&#34;版本发布管理&#34;&gt;版本发布管理&lt;/h3&gt;

&lt;p&gt;目前只支持对最近版本的恢复。&lt;a href=&#34;https://github.com/ctripcorp/apollo/issues/1642&#34;&gt;https://github.com/ctripcorp/apollo/issues/1642&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;灰度发布&#34;&gt;灰度发布&lt;/h3&gt;

&lt;h3 id=&#34;权限管理-发布审核-操作审计&#34;&gt;权限管理、发布审核、操作审计&lt;/h3&gt;

&lt;p&gt;编辑与发布是两个独立的操作。&lt;/p&gt;

&lt;h3 id=&#34;客户端配置信息监控&#34;&gt;客户端配置信息监控&lt;/h3&gt;

&lt;h3 id=&#34;提供java和-dot-net原生客户端&#34;&gt;提供Java和.Net原生客户端&lt;/h3&gt;

&lt;h3 id=&#34;提供开放平台api&#34;&gt;提供开放平台API&lt;/h3&gt;

&lt;p&gt;这样可以通过其它方式来查看配置信息，&lt;a href=&#34;https://github.com/ctripcorp/apollo/wiki/Apollo%25E5%25BC%2580%25E6%2594%25BE%25E5%25B9%25B3%25E5%258F%25B0&#34;&gt;平台API说明&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用方便的后台配置系统portal&#34;&gt;使用方便的后台配置系统Portal&lt;/h3&gt;

&lt;h3 id=&#34;分布式部署相对较复杂-这是缺点&#34;&gt;分布式部署相对较复杂，这是缺点&lt;/h3&gt;

&lt;p&gt;外部依赖少，目前依赖Mysql&lt;/p&gt;

&lt;h2 id=&#34;apollo的组成&#34;&gt;Apollo的组成&lt;/h2&gt;

&lt;h3 id=&#34;apollo长什么样&#34;&gt;Apollo长什么样?&lt;/h3&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/apollo-home-screenshot.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/apollo-home-screenshot.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h3 id=&#34;apollo整体设计&#34;&gt;Apollo整体设计&lt;/h3&gt;

&lt;h4 id=&#34;总体架构&#34;&gt;总体架构&lt;/h4&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/apollo-overall-architecture.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/apollo-overall-architecture.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h4 id=&#34;代码结构&#34;&gt;代码结构&lt;/h4&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/apollo-code-structure.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/apollo-code-structure.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href=&#34;https://github.com/ctripcorp/apollo/wiki/Apollo%25E9%2585%258D%25E7%25BD%25AE%25E4%25B8%25AD%25E5%25BF%2583%25E8%25AE%25BE%25E8%25AE%25A1#13-%25E5%2590%2584%25E6%25A8%25A1%25E5%259D%2597%25E6%25A6%2582%25E8%25A6%2581%25E4%25BB%258B%25E7%25BB%258D&#34;&gt;各模块概要介绍&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;apollo-config-service&#34;&gt;Apollo Config Service&lt;/h3&gt;

&lt;p&gt;提供配置获取接口，服务对象为Apollo客户端&lt;/p&gt;

&lt;h3 id=&#34;apollo-admin-service&#34;&gt;Apollo Admin Service&lt;/h3&gt;

&lt;p&gt;提供配置管理（修改、发布）接口，服务与Portal&lt;/p&gt;

&lt;h3 id=&#34;apollo-portal&#34;&gt;Apollo Portal&lt;/h3&gt;

&lt;p&gt;提供WEB界面供用户管理配置&lt;/p&gt;

&lt;h2 id=&#34;apollo的重要设计&#34;&gt;Apollo的重要设计&lt;/h2&gt;

&lt;h3 id=&#34;admin-service与config-service的通信方式&#34;&gt;Admin Service与Config Service的通信方式&lt;/h3&gt;

&lt;p&gt;Apollo使用Mysql实现消息(ReleaseMessage)的处理，消息内容为AppId+Cluster+Namespace，具体的设计思想可以参考&lt;a href=&#34;https://github.com/ctripcorp/apollo/wiki/Apollo%25E9%2585%258D%25E7%25BD%25AE%25E4%25B8%25AD%25E5%25BF%2583%25E8%25AE%25BE%25E8%25AE%25A1#211-%25E5%258F%2591%25E9%2580%2581releasemessage%25E7%259A%2584%25E5%25AE%259E%25E7%258E%25B0%25E6%2596%25B9%25E5%25BC%258F&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/apollo-release-message-design.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/apollo-release-message-design.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h3 id=&#34;客户端与服务端的通信方式&#34;&gt;客户端与服务端的通信方式&lt;/h3&gt;

&lt;p&gt;客户端与服务端保持一个长连接(通过Http Long Polling实现)
&lt;a href=&#34;~/github/apollo/doc/images/client-architecture.png&#34;&gt;Client Server&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;重要的namespace&#34;&gt;重要的Namespace&lt;/h3&gt;

&lt;p&gt;Namespace是配置项的集合，类似于一个配置文件的概念，获取的权限分为private与public两种权限。&lt;/p&gt;

&lt;h4 id=&#34;namespace的类型&#34;&gt;Namespace的类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;私有类型&lt;/li&gt;
&lt;li&gt;公有类型&lt;/li&gt;
&lt;li&gt;关联类型（继承类型）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cluster能用来做什么&#34;&gt;Cluster能用来做什么?&lt;/h3&gt;

&lt;p&gt;分机房实例，分任务功能实例，比如在一些实例执行job，需要增加-Dapollo.cluster=配置指定集群名&lt;/p&gt;

&lt;h2 id=&#34;体验部署方式&#34;&gt;体验部署方式&lt;/h2&gt;

&lt;p&gt;Docker，本地源代码，虚拟机多环境&lt;/p&gt;

&lt;h2 id=&#34;使用注意事项&#34;&gt;使用注意事项&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在主版本有未发布的配置项时，要发布灰度后的全量则需要先把主版本中的配置发布后方可操作&lt;/li&gt;
&lt;li&gt;使用docker运行demo测试时连接不上docker中的服务解决方法：&lt;a href=&#34;https://github.com/ctripcorp/apollo/issues/1481#issuecomment-422057411w&#34;&gt;https://github.com/ctripcorp/apollo/issues/1481#issuecomment-422057411w&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;/opt目录要有读写权限，日志文件默认打印在此目录&lt;/li&gt;
&lt;li&gt;Client端要使用本地缓存配置，默认情况下确保/opt/data目录存在&lt;/li&gt;
&lt;li&gt;线上环境配置建议配置在机器上，不建议配置在代码中，与代码解耦&lt;/li&gt;
&lt;li&gt;config与admin service要开放端口8080与8090(默认情况下)，端口可以在项目中的starup.sh中修改&lt;/li&gt;
&lt;li&gt;如果Config Service配置开启了内存缓存数据(config-service.cache.enabled)，要提前考虑数据量的大小，调整服务的内存配置&lt;/li&gt;
&lt;li&gt;在配置单环境(如开发环境)高可用时配置修改点

&lt;ul&gt;
&lt;li&gt;修改config库的eureka.service.url配置项为多个开发环境的meta server地址&lt;/li&gt;
&lt;li&gt;修改portal的apollo-env.properties文件中的开发环境指定地址&lt;/li&gt;
&lt;li&gt;修改admin与config的连接数据库地址，都连接到开发环境的mysql地址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;后续待确认问题处理&#34;&gt;后续待确认问题处理&lt;/h2&gt;

&lt;h3 id=&#34;客户端的读取权限&#34;&gt;客户端的读取权限&lt;/h3&gt;

&lt;p&gt;目前看官方没有对这方面进行处理，维护者已将该功能加为TODO。具体的实现方案看&lt;a href=&#34;https://github.com/ctripcorp/apollo/issues/2099#issuecomment-478240713&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;docker的实例获取问题&#34;&gt;docker的实例获取问题&lt;/h3&gt;

&lt;p&gt;验证的是实例列表获取的是docker实例的ip地址，不同的docker机获取的ip是相同的&lt;/p&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/apollo-docker-ip.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/apollo-docker-ip.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h3 id=&#34;本地调试读取配置问题&#34;&gt;本地调试读取配置问题&lt;/h3&gt;

&lt;p&gt;Apollo的开发模式可以解决这个问题，具体看&lt;a href=&#34;https://github.com/ctripcorp/apollo/wiki/Java%25E5%25AE%25A2%25E6%2588%25B7%25E7%25AB%25AF%25E4%25BD%25BF%25E7%2594%25A8%25E6%258C%2587%25E5%258D%2597#%25E4%25BA%2594%25E6%259C%25AC%25E5%259C%25B0%25E5%25BC%2580%25E5%258F%2591%25E6%25A8%25A1%25E5%25BC%258F&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;client怎么来修改配置&#34;&gt;Client怎么来修改配置&lt;/h3&gt;

&lt;p&gt;目前看Apllo-Client包只提供从配置中心获取配置的功能，如果想对配置进行修改，则只能通过OpenApi的方式来实现。&lt;/p&gt;

&lt;h3 id=&#34;配置指定时间生效&#34;&gt;配置指定时间生效&lt;/h3&gt;

&lt;p&gt;目前来看需要通过OpenApi实现&lt;/p&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ctripcorp/apollo&#34;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/nacos&#34;&gt;https://github.com/alibaba/nacos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dockone.io/article/8767&#34;&gt;http://dockone.io/article/8767&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>TARS-打卡第一天</title>
      <link>http://blog.imcompany.cn/post/tars-001/</link>
      <pubDate>Thu, 09 May 2019 17:34:09 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/tars-001/</guid>
      
        <description>

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;p&gt;LeetCode 第一题&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给一个int数组，返回数组中两个数字相加的和是目标 数的下标。可以假设每个输入只有一个解决方案，并且不能使用同一个元素两次。&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;给出nums = [2, 7, 11, 15], 目标数为9，则返回[0, 1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目解答&#34;&gt;题目解答&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            int second = target - nums[i];
            if(map.containsKey(second)) {
                return new int[]{map.get(second), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比两次循环的方式，这种处理的时间复杂度为O(n), 空间复杂度也为O(n).&lt;/p&gt;

&lt;h2 id=&#34;review&#34;&gt;Review&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/google-cloud/production-guideline-9d5d10c8f1e&#34;&gt;Google Cloud Production Guideline&lt;/a&gt;，本文主要是针对Google的Colud平台事故进行了线上发布的总结指导（检查列表）。详细如下：&lt;/p&gt;

&lt;h3 id=&#34;设计与开发&#34;&gt;设计与开发&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有可再生的构建系统，构建系统不能被外部的服务访问并且不能被一个外部的系统中断&lt;/li&gt;
&lt;li&gt;记录服务所信赖外部服务的可用性期望&lt;/li&gt;
&lt;li&gt;通过不信赖单个全局资源来避免单点故障，当资源不可用时，资源复制或者设置适当的回退（例如硬编码值）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置管理&#34;&gt;配置管理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;静态的，小的和非加密配置可以是命令行标识。使用配置传送服务来完成其它任务&lt;/li&gt;
&lt;li&gt;在配置系统不可用时，动态系统需要有一个可合理回退&lt;/li&gt;
&lt;li&gt;开发环境的配置不应该从生产环境继承。这样可能导致从开发环境访问生产服务，并可能导致隐私问题和数据泄漏。&lt;/li&gt;
&lt;li&gt;记录可以动态配置的内容，并且说明当服务传送服务不可达时的回退行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;发布管理&#34;&gt;发布管理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;记录关于发布过程的所有明细。记录发布如何影响SLOs（比如由于缓存丢失导致的临时更高延迟）&lt;/li&gt;
&lt;li&gt;记录服务的金丝雀发布过程&lt;/li&gt;
&lt;li&gt;有一个金丝雀的分析计划，如果可能的话，设置机制支持自动化恢复金丝雀的机制&lt;/li&gt;
&lt;li&gt;确保回退使用相同的操作来持续使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;可观察性&#34;&gt;可观察性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;确保从二进制文件中收集并导出SLOs所需的度量集合&lt;/li&gt;
&lt;li&gt;确保客户端与服务端的可观察性数据是分开的。这个在生产环境调试时很重要&lt;/li&gt;
&lt;li&gt;调整报警以减少工作量，例如删除日常事件触发的报警&lt;/li&gt;
&lt;li&gt;总是传递入参的跟踪上下文，这样对于系统调试有很大的帮助&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安全和保护&#34;&gt;安全和保护&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;保证所有的外部请求都已加密&lt;/li&gt;
&lt;li&gt;使用项目来完全隔离资源&lt;/li&gt;
&lt;li&gt;在项目中使用网络来隔离VM实例组&lt;/li&gt;
&lt;li&gt;使用云VPN来进行远程连接&lt;/li&gt;
&lt;li&gt;记录与监听用户的数据访问，确保所有用户的数据访问是被记录与审查的&lt;/li&gt;
&lt;li&gt;确保调试节点是被ACL限制的&lt;/li&gt;
&lt;li&gt;处理用户的输入，为用户输入设置有效负载大小限制&lt;/li&gt;
&lt;li&gt;确保服务可以有选择的阻塞每个用户的传入流量。这允许在不影响其它用户的情况下阻止滥用行为&lt;/li&gt;
&lt;li&gt;避免外部节点引发大量的内部扩张&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;容量计划&#34;&gt;容量计划&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;记录服务的负载。例如用户数,入口流量，入口信息量&lt;/li&gt;
&lt;li&gt;记录服务的资源请求，例如可用的VM实例数，硬件如GPUs和TPUs&lt;/li&gt;
&lt;li&gt;记录资源的约束：资源类型，范围等等&lt;/li&gt;
&lt;li&gt;记录创建新资源的配额限制&lt;/li&gt;
&lt;li&gt;在可能的情况下进行性能回归的负载测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tip&#34;&gt;Tip&lt;/h2&gt;

&lt;p&gt;在Emacs的Dired中进行快速的写操作(批量修改文件名等)，操作步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M-x dired&lt;/li&gt;
&lt;li&gt;C-x C-q (开启dired buffer的只读模式)&lt;/li&gt;
&lt;li&gt;M-x query-replace (执行查找并替换)&lt;/li&gt;
&lt;li&gt;C-c C-c (保存修改)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;搞定，批量重命名文件就是这么简单.&lt;/p&gt;

&lt;h2 id=&#34;share&#34;&gt;Share&lt;/h2&gt;

&lt;p&gt;今天分享一篇通俗易懂方式来讲解多线程的文章，在文章中作者说明了进程与线程的区别，单核CPU下的多任务方式（假多任务），多核CPU下的多任务方式（真正的并发）,也讲述了在多线程情况下产生的问题，如数据竞争与竞态条件，以及编写多线程时保证程序正确的方法，如同步，原子操作，数据不可变等等。&lt;a href=&#34;https://www.internalpointers.com/post/gentle-introduction-multithreading&#34;&gt;A gentle introduction to multithreading&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Centos7 install issue collect</title>
      <link>http://blog.imcompany.cn/post/centos7-install-issue-collect/</link>
      <pubDate>Mon, 06 May 2019 13:00:55 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/centos7-install-issue-collect/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;由于工作需要，使用VMWare虚拟机安装了Centos7系统，遇到了很多问题，现在把这些问题记录下来，以备后用。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决centos7-yum-could-not-retrieve-mirrorlist错误&#34;&gt;解决Centos7 yum could not retrieve mirrorlist错误&lt;/h2&gt;

&lt;p&gt;刚安装好的VM使用ip add查看局域网的ip没有结果，这个参考&lt;a href=&#34;https://my.oschina.net/u/2456768/blog/3011881&#34;&gt;https://my.oschina.net/u/2456768/blog/3011881&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置静态ip&#34;&gt;配置静态ip&lt;/h2&gt;

&lt;p&gt;安装虚拟机就是模拟多个机器通讯的情况，但是目前的配置是机器ip是动态获取的，老是变，每次都得看ip，所以需要配置一下VMware来支持静态ip。主要机器上的配置信息为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;IPADDR=192.168.116.101
NETMASK=255.255.255.0
GATEWAY=192.168.116.2
DNS1=192.168.116.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个参考了&lt;a href=&#34;https://blog.csdn.net/zhishengqianjun/article/details/77046796&#34;&gt;https://blog.csdn.net/zhishengqianjun/article/details/77046796&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;centos7安装后配置国内仓库源&#34;&gt;Centos7安装后配置国内仓库源&lt;/h2&gt;

&lt;p&gt;由于国内访问centos的原始源慢，需要换成163的软件源，新安装的系统执行命令都提示not found，只能从物理下载源的配置再上传到VM中，但是首先得知道VM的ip地址，使用ifconfig是不可能了，查了一下可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ip a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来查看VM的ip地址，这样配置源的的问题可以解决了，具体的配置源的方法参考&lt;a href=&#34;https://blog.csdn.net/inslow/article/details/54177191&#34;&gt;https://blog.csdn.net/inslow/article/details/54177191&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;centos7安装vmware-tools&#34;&gt;Centos7安装VMware Tools&lt;/h3&gt;

&lt;p&gt;想更好的让VM与物理机协同，则VMware Tools必须要安装，好久不用linux的我连挂载也忘的一干二净了。搜了一下，参考&lt;a href=&#34;https://blog.csdn.net/WarnerWu/article/details/73718901&#34;&gt;https://blog.csdn.net/WarnerWu/article/details/73718901&lt;/a&gt; 完成VMware Tools的安装。这样共享目录的功能就可以正常使用了&lt;/p&gt;

&lt;h2 id=&#34;安装jdk8&#34;&gt;安装Jdk8&lt;/h2&gt;

&lt;p&gt;一句命令搞定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装mysql&#34;&gt;安装mysql&lt;/h2&gt;

&lt;p&gt;使用yum安装mysql需要下载安装mysql的源，更新后就可以安装了，这个参考了&lt;a href=&#34;https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7/&#34;&gt;https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;修改mysql的root密码&#34;&gt;修改mysql的root密码&lt;/h2&gt;

&lt;p&gt;安装完mysql后登录找不到密码了，其实在使用yum安装时会mysql会自动生成一个随机密码，这个密码可以在安装的日志中找到。此方法参考了&lt;a href=&#34;https://blog.csdn.net/kuluzs/article/details/51924086&#34;&gt;https://blog.csdn.net/kuluzs/article/details/51924086&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;开放3306端口&#34;&gt;开放3306端口&lt;/h2&gt;

&lt;p&gt;为了方便mysql工具进行操作，需要开放3306端口。Centos7的防火墙还改了。具体就3个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start firewalld
firewall-cmd --zone=public --add-port=3306/tcp --permanent
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个参考了&lt;a href=&#34;https://www.jianshu.com/p/225a853350d9&#34;&gt;https://www.jianshu.com/p/225a853350d9&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装oh-my-bash&#34;&gt;安装oh-my-bash&lt;/h2&gt;

&lt;p&gt;由于一般服务器都自带bash为默认的shell，但是操作起来着实不方便，安装oh-my-bash可以对shell进行一些增强。&lt;a href=&#34;https://github.com/ohmybash/oh-my-bash&#34;&gt;https://github.com/ohmybash/oh-my-bash&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;centos自动登录&#34;&gt;Centos自动登录&lt;/h2&gt;

&lt;p&gt;安装后每次启动VM都要输入密码，这个对于自己测试很麻烦，要使Centos能登录后自动登录需要做以下操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;移除原来的getty@tty1.service软链接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rm /etc/systemd/system/getty.target.wants/getty@tty1.service
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拷贝getty@.service file 并且命名为 getty@tty1.service&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cp /lib/systemd/system/getty@.service /etc/systemd/system/getty@tty1.service
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑新拷贝的getty@tty1.service，修改以下内容，最后一行必须加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[Service]
...
ExecStart=-/sbin/agetty --autologin root --noclear %I
...
[Install]
...
;Alias=getty@tty1.service
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在getty.target.wants目录做一下软链接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ln -s /etc/systemd/system/getty@tty1.service /etc/systemd/system/getty.target.wants/getty@tty1.service
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启，Done!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;以上参考&lt;a href=&#34;https://www.centos.org/forums/viewtopic.php?t=48288&#34;&gt;https://www.centos.org/forums/viewtopic.php?t=48288&lt;/a&gt;
  说明一下，网上一些修改gdm的方法试了没有作用。&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>那些高效的Chrome插件</title>
      <link>http://blog.imcompany.cn/post/na-xie-gao-xiao-de-chromecha-jian/</link>
      <pubDate>Fri, 08 Mar 2019 07:48:34 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/na-xie-gao-xiao-de-chromecha-jian/</guid>
      
        <description>

&lt;h2 id=&#34;1password-extension&#34;&gt;1Password extension&lt;/h2&gt;

&lt;p&gt;密码管理工具1Password的Chrome插件。&lt;a href=&#34;https://chrome.google.com/webstore/detail/1password-extension-deskt/aomjjhallfgjeglblehebfpbcfeobpgk&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;auto-refresh&#34;&gt;Auto Refresh&lt;/h2&gt;

&lt;p&gt;自动刷新网页的插件，支持设置刷新时间间隔。&lt;a href=&#34;https://chrome.google.com/webstore/detail/auto-refresh/ifooldnmmcmlbdennkpdnlnbgbmfalko&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;awesome-autocomplete-for-github&#34;&gt;Awesome Autocomplete for GitHub&lt;/h2&gt;

&lt;p&gt;在浏览器中为Github增强搜索功能。&lt;a href=&#34;https://github.com/algolia/github-awesome-autocomplete&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;bettertweetdeck&#34;&gt;BetterTweetDeck&lt;/h2&gt;

&lt;p&gt;TweetDeck功能增强，如支持表情，只看某人的tweets，&lt;a href=&#34;https://better.tw/&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;chrono下载管理器&#34;&gt;&lt;del&gt;Chrono下载管理器&lt;/del&gt;&lt;/h2&gt;

&lt;p&gt;功能全面的chrome下载管理器，满足你的一切需求。&lt;a href=&#34;https://chrome.google.com/webstore/detail/chrono-download-manager/mciiogijehkdemklbdcbfkefimifhecn&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;clutter-free-prevent-duplicate-tabs&#34;&gt;Clutter Free - Prevent duplicate tabs&lt;/h2&gt;

&lt;p&gt;防止打开相同的tab页面。&lt;a href=&#34;https://chrome.google.com/webstore/detail/clutter-free-prevent-dupl/iipjdmnoigaobkamfhnojmglcdbnfaaf&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;dualsub&#34;&gt;Dualsub&lt;/h2&gt;

&lt;p&gt;让Youtube同时显示两种语言的字幕。&lt;a href=&#34;https://github.com/muzuiget/dualsub-supports&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;github-hovercard&#34;&gt;GitHub Hovercard&lt;/h2&gt;

&lt;p&gt;鼠标Hover时更全面显示Github上个人与仓库的信息。&lt;a href=&#34;https://github.com/Justineo/github-hovercard&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;insight-dot-io-for-github&#34;&gt;Insight.io for Github&lt;/h2&gt;

&lt;p&gt;为Github添加类似IDE的功能，高效的代码浏览工具。&lt;a href=&#34;https://github.com/apps/insight-io-code-review&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;json-handle&#34;&gt;JSON-handle&lt;/h2&gt;

&lt;p&gt;JSON数据处理插件。&lt;a href=&#34;https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;json-viewer-awesome&#34;&gt;JSON Viewer Awesome&lt;/h2&gt;

&lt;p&gt;JSON数据美化，漂亮的不行不行的。&lt;a href=&#34;https://chrome.google.com/webstore/detail/json-viewer-awesome/iemadiahhbebdklepanmkjenfdebfpfe/related&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;org-capture&#34;&gt;Org Capture&lt;/h2&gt;

&lt;p&gt;Org Capture的Chrome插件，支持Capture网页链接与选中文字，配合Emacs使用。&lt;a href=&#34;https://github.com/sprig/org-capture-extension&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mama-hd&#34;&gt;MAMA-HD&lt;/h2&gt;

&lt;p&gt;解决在看视频网站时Mac发热的问题。&lt;a href=&#34;https://github.com/nareix/mama-hd&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;proxy-switchyomega&#34;&gt;Proxy SwitchyOmega&lt;/h2&gt;

&lt;p&gt;网页代理切换，支持定义多种模式。&lt;a href=&#34;https://github.com/FelisCatus/SwitchyOmega&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sourcegraph&#34;&gt;Sourcegraph&lt;/h2&gt;

&lt;p&gt;在线浏览Github的源码，支持一些语言的语义跳转。&lt;a href=&#34;https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;surfingkeys&#34;&gt;Surfingkeys&lt;/h2&gt;

&lt;p&gt;严重推荐，VIM键盘模拟，自定义程度非常高。&lt;a href=&#34;https://github.com/brookhong/Surfingkeys&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tampermonkey&#34;&gt;Tampermonkey&lt;/h2&gt;

&lt;p&gt;用户自定义脚本管理器。&lt;a href=&#34;https://github.com/Tampermonkey/tampermonkey&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;yaaw-for-chrome&#34;&gt;YAAW for Chrome&lt;/h2&gt;

&lt;p&gt;使用YAAW处理Chrome的下载请求。&lt;a href=&#34;https://github.com/acgotaku/YAAW-for-Chrome&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;二管家&#34;&gt;二管家&lt;/h2&gt;

&lt;p&gt;Chrome扩展管理器，快速开启、禁用，模式快速切换，更强大的是可以自定义插件的启用规则，这个很赞。&lt;a href=&#34;https://chrome.google.com/webstore/detail/nooboss/aajodjghehmlpahhboidcpfjcncmcklf&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;二箱&#34;&gt;二箱&lt;/h2&gt;

&lt;p&gt;多个网站的以图搜图插件，能用图说的咱决不打字。&lt;a href=&#34;https://chrome.google.com/webstore/detail/noobox-search-by-image/kidibbfcblfbbafhnlanccjjdehoahep&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;沙拉查词-聚合词典划词翻译&#34;&gt;沙拉查词-聚合词典划词翻译&lt;/h2&gt;

&lt;p&gt;更人性化的划词扩展。&lt;a href=&#34;https://github.com/crimx/ext-saladict&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;简悦-simpread&#34;&gt;简悦 - SimpRead&lt;/h2&gt;

&lt;p&gt;沉浸式阅读首选，支持大多数的网站。&lt;a href=&#34;https://github.com/Kenshin/simpread&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;clearly&#34;&gt;Clearly&lt;/h2&gt;

&lt;p&gt;更好的英文网页浏览选择，带文字朗读功能。&lt;a href=&#34;https://chrome.google.com/webstore/detail/clearly/odfonlkabodgbolnmmkdijkaeggofoop&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;read-aloud&#34;&gt;Read Aloud&lt;/h2&gt;

&lt;p&gt;朗读英文文章的更好选择，它只会朗读标题与正文。可以选择朗读语间，音调，速度。&lt;a href=&#34;https://chrome.google.com/webstore/detail/read-aloud-a-text-to-spee/hdhinadidafjejdhmfkjgnolgimiaplp/related&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;彩云小译&#34;&gt;彩云小译&lt;/h2&gt;

&lt;p&gt;英文网页同步翻译，译文在原文的下面，方便学习。&lt;a href=&#34;https://chrome.google.com/webstore/detail/lingocloud-interpreter/jmpepeebcbihafjjadogphmbgiffiajh?utm_source=chrome-ntp-icon&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;掘金&#34;&gt;掘金&lt;/h2&gt;

&lt;p&gt;开发必备，每天看看IT界发生了啥。&lt;a href=&#34;https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;github-history&#34;&gt;Github History&lt;/h2&gt;

&lt;p&gt;方便的查看github上文件的修改历史。安装Cli工具可以查看本地文件修改历史。&lt;a href=&#34;https://github.com/pomber/git-history&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;remu&#34;&gt;Remu&lt;/h2&gt;

&lt;p&gt;在Chrome插件管理github的star，尝试中。&lt;a href=&#34;https://chrome.google.com/webstore/detail/remu/bajifjohhghngljcfhkbpcggafpiajdo&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ublock-origin&#34;&gt;uBlock Origin&lt;/h2&gt;

&lt;p&gt;高效的网络请求过滤插件，与广告Say ByeBye，占用系统资源小。&lt;a href=&#34;https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ghosttext&#34;&gt;GhostText&lt;/h2&gt;

&lt;p&gt;使用Emacs或者其它编辑器来编辑浏览器中的TextArea，高效且实时同步。&lt;a href=&#34;https://github.com/GhostText/GhostText&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>那些提高效率的命令行工具</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ming-ling-xing-gong-ju/</link>
      <pubDate>Sun, 30 Sep 2018 07:15:55 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ming-ling-xing-gong-ju/</guid>
      
        <description>

&lt;h2 id=&#34;brew&#34;&gt;Brew&lt;/h2&gt;

&lt;p&gt;Mac软件包管理工具。用命令行命令来安装软件，仓库软件丰富。&lt;a href=&#34;https://github.com/Homebrew/brew&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;bat&#34;&gt;bat&lt;/h2&gt;

&lt;p&gt;bat? No，高端cat，不费眼。带颜色显示，支持git状态，自动分页。&lt;a href=&#34;https://github.com/sharkdp/bat&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cowsay&#34;&gt;cowsay&lt;/h2&gt;

&lt;p&gt;奶牛说： &lt;a href=&#34;https://github.com/piuccio/cowsay&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;coreutils&#34;&gt;coreutils&lt;/h2&gt;

&lt;p&gt;使用Rust重写的gnuutils。&lt;a href=&#34;https://github.com/uutils/coreutils&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;direnv&#34;&gt;direnv&lt;/h2&gt;

&lt;p&gt;环境变量切换，可以指定在进入某一文件夹后的操作，比如输出一条欢迎语句，在退出文件夹后则卸载变量（操作），它的&lt;a href=&#34;https://github.com/direnv/direnv/blob/master/stdlib.sh%0A%0A&#34;&gt;stdlib&lt;/a&gt;内置了一些功能来处理环境。 &lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exa&#34;&gt;exa&lt;/h2&gt;

&lt;p&gt;ls、tree的替代者，支持多种显示方式，支持按指定条件排序显示。&lt;a href=&#34;https://github.com/ogham/exa&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;duti&#34;&gt;duti&lt;/h2&gt;

&lt;p&gt;mac默认软件打开程序配置。再也不用一个手动的点击设置了，可以脚本化。&lt;a href=&#34;https://github.com/moretension/duti&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;riggrep&#34;&gt;riggrep&lt;/h2&gt;

&lt;p&gt;强大的find，查询速度更快，支持匹配结果的字符替换，支持定义输出颜色。&lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fortune&#34;&gt;fortune&lt;/h2&gt;

&lt;p&gt;英文名言集合，可以使用&lt;a href=&#34;https://github.com/ruanyf/fortunes&#34;&gt;fortunes&lt;/a&gt;进行扩展，对中文用户更友好。&lt;a href=&#34;https://www.ibiblio.org/pub/linux/games/amusements/fortune/!INDEX.html&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fzf&#34;&gt;fzf&lt;/h2&gt;

&lt;p&gt;强大的交互式搜索，大大提高效率，官网提供了很多实用的操作目录与git的命令。&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;goku&#34;&gt;goku&lt;/h2&gt;

&lt;p&gt;改键神器Karabiner的配置管理器，更健康，更人性化。&lt;a href=&#34;https://github.com/yqrashawn/GokuRakuJoudo&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;htop&#34;&gt;htop&lt;/h2&gt;

&lt;p&gt;交互式的top信息显示，支持配色。&lt;a href=&#34;https://github.com/hishamhm/htop&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;imgcat&#34;&gt;imgcat&lt;/h2&gt;

&lt;p&gt;命令行看图片。可以控制显示的高度、宽度。&lt;a href=&#34;https://github.com/eddieantonio/imgcat&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jq&#34;&gt;jq&lt;/h2&gt;

&lt;p&gt;json内容操作显示。支持分离、过滤、转换元素，判断JSON元素节点是否存在等功能，内置了很多方便的函数。 &lt;a href=&#34;https://github.com/stedolan/jq&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jenv&#34;&gt;jenv&lt;/h2&gt;

&lt;p&gt;JDK版本管理命令行工具，支持全局、当前目录、当前shell的jdk版本指定。还可以指定Java虚拟机指定的JVM参数。支持插件的启用与禁用。&lt;a href=&#34;https://www.jenv.be/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lnav&#34;&gt;lnav&lt;/h2&gt;

&lt;p&gt;log file navigator，增加的日志查看，可以根据日志级别显示不同颜色的日志信息。支持分页显示。&lt;a href=&#34;https://github.com/tstack/lnav&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lolcat&#34;&gt;lolcat&lt;/h2&gt;

&lt;p&gt;命令、文件内容多彩输出。&lt;a href=&#34;https://github.com/busyloop/lolcat&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;m-cli&#34;&gt;m-cli&lt;/h2&gt;

&lt;p&gt;Mac的瑞士军刀，支持各种mac组件(Dock，蓝牙，WIFI，Finder)的操作。&lt;a href=&#34;https://github.com/rgcr/m-cli&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mackup&#34;&gt;mackup&lt;/h2&gt;

&lt;p&gt;Mac应用配置同步，支持多种存储方式。支持自定义应用的同步配置。主要命令为backup，restore，uninstall。&lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mas&#34;&gt;mas&lt;/h2&gt;

&lt;p&gt;命令行安装apple store应用。&lt;a href=&#34;https://github.com/mas-cli/mas&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mycli&#34;&gt;mycli&lt;/h2&gt;

&lt;p&gt;命令行中的mysql客户端。&lt;a href=&#34;https://github.com/dbcli/mycli&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ncdu&#34;&gt;ncdu&lt;/h2&gt;

&lt;p&gt;增强版本的du，机器空间使用查询，支持扫描结果导出与导入，支持多种排序方式。&lt;a href=&#34;https://dev.yorhel.nl/ncdu&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ranger&#34;&gt;Ranger&lt;/h2&gt;

&lt;p&gt;命令行下的文件管理，强大到没朋友。&lt;a href=&#34;https://github.com/ranger/ranger&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pandoc&#34;&gt;pandoc&lt;/h2&gt;

&lt;p&gt;文档转换，支持非常多的的格式转换。&lt;a href=&#34;https://pandoc.org/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pyenv&#34;&gt;pyenv&lt;/h2&gt;

&lt;p&gt;pythne版本管理工具。&lt;a href=&#34;https://github.com/pyenv/pyenv&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pyenv-virtualenv&#34;&gt;pyenv-virtualenv&lt;/h2&gt;

&lt;p&gt;pythne虚拟环境管理，管理pyenv配置的环境。&lt;a href=&#34;https://github.com/pyenv/pyenv-virtualenv&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;prettyping&#34;&gt;prettyping&lt;/h2&gt;

&lt;p&gt;增强的ping，图形化显示，可以轻松的看出ping的地址的网络状况。&lt;a href=&#34;http://denilson.sa.nom.br/prettyping/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rtv&#34;&gt;rtv&lt;/h2&gt;

&lt;p&gt;命令行中浏览reddit。&lt;a href=&#34;https://github.com/michael-lazar/rtv&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;s-search&#34;&gt;s-search&lt;/h2&gt;

&lt;p&gt;命令行下进行web搜索。&lt;a href=&#34;https://github.com/zquestz/s&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tmux&#34;&gt;tmux&lt;/h2&gt;

&lt;p&gt;终端多会话管理器。&lt;a href=&#34;https://github.com/tmux/tmux&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tldr&#34;&gt;tldr&lt;/h2&gt;

&lt;p&gt;命令快速查询。简单的man。&lt;a href=&#34;https://tldr.sh/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;terminal-notify&#34;&gt;Terminal Notify&lt;/h2&gt;

&lt;p&gt;命令行操作mac显示通知，支持图标显示与点击后操作（如打开网址，执行命令）等。&lt;a href=&#34;https://github.com/julienXX/terminal-notifier&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;w3m&#34;&gt;w3m&lt;/h2&gt;

&lt;p&gt;终端浏览器，操作方便。&lt;a href=&#34;http://w3m.sourceforge.net/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wrk&#34;&gt;wrk&lt;/h2&gt;

&lt;p&gt;系统性能测试工具。&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wd&#34;&gt;wd&lt;/h2&gt;

&lt;p&gt;快速的cd到常用的目录，支持命令增加，查询功能。&lt;a href=&#34;https://github.com/mfaerevaag/wd&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;youtube-dl&#34;&gt;youtube-dl&lt;/h2&gt;

&lt;p&gt;youtube视频下载，也支持其它网站的视频下载。支持配置文件配置下载的选项。&lt;a href=&#34;https://github.com/rg3/youtube-dl&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;diffoscope&#34;&gt;diffoscope&lt;/h2&gt;

&lt;p&gt;文件，文件夹内容比较。支持比较的文件格式非常丰富。&lt;a href=&#34;https://diffoscope.org/&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;speedtest&#34;&gt;speedtest&lt;/h2&gt;

&lt;p&gt;cli 网络测速。&lt;a href=&#34;https://github.com/sivel/speedtest-cli&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modd&#34;&gt;modd&lt;/h2&gt;

&lt;p&gt;文件变更监听响应，在文件变化时执行相应的配置动作。&lt;a href=&#34;https://github.com/cortesi/modd&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;gron&#34;&gt;gron&lt;/h2&gt;

&lt;p&gt;将JSON文本转换为离散的赋值语句，以便查找。&lt;a href=&#34;https://github.com/tomnomnom/gron&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pathpicker&#34;&gt;PathPicker&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/PathPicker&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;peco&#34;&gt;Peco&lt;/h2&gt;

&lt;p&gt;简单的交互式过滤工具。&lt;a href=&#34;https://github.com/peco/peco&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hub&#34;&gt;Hub&lt;/h2&gt;

&lt;p&gt;github官方品，对github的封装，可以更任性的来玩github。&lt;a href=&#34;https://github.com/github/hub&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>那些提高效率的Alfred Workflow</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-alfred-workflow/</link>
      <pubDate>Fri, 21 Sep 2018 10:02:49 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-alfred-workflow/</guid>
      
        <description>

&lt;h2 id=&#34;alfred-browser-toolbox&#34;&gt;Alfred Browser Toolbox&lt;/h2&gt;

&lt;p&gt;Toolbox是一个文件操作浏览的工具，它支持创建、查找文件的功能，还可以查询pdf文件，非常方便。Mac上的Finder使用确定不方便。&lt;a href=&#34;https://www.alfredforum.com/topic/5166-copymove-to-and-alfred-browser-workflows/&#34;&gt;这里&lt;/a&gt;有具体的使用方式。&lt;/p&gt;

&lt;h2 id=&#34;alfred-keywords-help&#34;&gt;Alfred Keywords Help&lt;/h2&gt;

&lt;p&gt;安装的workflow多了，记忆触发的keyword就比较困难，使用&lt;a href=&#34;https://github.com/pochemuto/alfred-help-workflow&#34;&gt;Keywords help&lt;/a&gt;这个插件可以显示出所有已经安装的workflow的触发key，还可以根据workflow进行查询。&lt;/p&gt;

&lt;h2 id=&#34;alfred-maestro&#34;&gt;Alfred Maestro&lt;/h2&gt;

&lt;p&gt;操作Maestro的workflow，可以直接查找macro并执行。&lt;a href=&#34;https://github.com/iansinnott/alfred-maestro&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;alfred-my-mind&#34;&gt;Alfred My Mind&lt;/h2&gt;

&lt;p&gt;快速查询&lt;a href=&#34;https://nikitavoloboev.xyz/&#34;&gt;Nikita&lt;/a&gt;的githubpage内容的workflow，我在他的文章里面学到了很多。&lt;a href=&#34;https://github.com/nikitavoloboev/alfred-my-mind#readme&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;awesome-lists&#34;&gt;Awesome lists&lt;/h2&gt;

&lt;p&gt;快速查询Github上awesome列表的workflow，只为发现更多。&lt;a href=&#34;https://github.com/nikitavoloboev/alfred-awesome-lists&#34;&gt;插件地址&lt;/a&gt;，这个也是Nikita的作品。&lt;/p&gt;

&lt;h2 id=&#34;baidu-map&#34;&gt;Baidu Map&lt;/h2&gt;

&lt;p&gt;在alfred上使用百度地图。&lt;a href=&#34;https://github.com/wofeiwo/alfred-baidu-map&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;birthday&#34;&gt;Birthday&lt;/h2&gt;

&lt;p&gt;在alfred中显示你来到这个世界多长时间，让你珍惜每一分，每一秒。&lt;a href=&#34;https://github.com/nikitavoloboev/small-workflows/tree/master/birthday#readme&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;calendar&#34;&gt;Calendar&lt;/h2&gt;

&lt;p&gt;在alfred中显示出当月的日历信息。&lt;a href=&#34;https://github.com/owenwater/alfred-cal&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;chromes-bookmarks&#34;&gt;Chromes Bookmarks&lt;/h2&gt;

&lt;p&gt;在aflred中搜索Chrome浏览器的书签，非常的好用。&lt;a href=&#34;https://github.com/blainesch/alfred-chrome-bookmarks&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;common-search&#34;&gt;Common Search&lt;/h2&gt;

&lt;p&gt;国内常用网站的搜索，现在支持知乎、淘宝、掘金、github。&lt;a href=&#34;https://github.com/MuYunyun/commonSearch&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;dash&#34;&gt;Dash&lt;/h2&gt;

&lt;p&gt;在alfred中进行Dash的搜索，开发者必备。&lt;a href=&#34;https://github.com/Kapeli/Dash-Alfred-Workflow&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;directory-watches&#34;&gt;Directory watches&lt;/h2&gt;

&lt;p&gt;本地目录文件查看，指定目录的搜索，回收站文件显示。&lt;/p&gt;

&lt;h2 id=&#34;emacs-workflow&#34;&gt;Emacs Workflow&lt;/h2&gt;

&lt;p&gt;在alfred中进行emacs的操作，比如打开文件等。&lt;a href=&#34;https://www.alfredforum.com/topic/8444-emacs-workflow/&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;eudic&#34;&gt;Eudic&lt;/h2&gt;

&lt;h3 id=&#34;插件说明&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;使用欧路词典进行快速翻译。&lt;a href=&#34;https://github.com/cdpath/eudic_tools&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git-repos&#34;&gt;Git Repos&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-1&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;搜索本地的git文件夹，搜索到后可以使用指定软件进行打开，开发时很有用。&lt;a href=&#34;https://github.com/deanishe/alfred-repos&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;插件说明-2&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;搜索github上的项目，可以搜索项目，人物等。&lt;a href=&#34;https://github.com/gharlan/alfred-github-workflow&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;google-chrome-history&#34;&gt;Google Chrome History&lt;/h2&gt;

&lt;p&gt;在alfred中快速查看Chrome的浏览历史。&lt;a href=&#34;https://github.com/tupton/alfred-chrome-history&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hammerspoon-workflow&#34;&gt;Hammerspoon Workflow&lt;/h2&gt;

&lt;p&gt;在alfred中调用hammerspon脚本的workflow。&lt;a href=&#34;https://www.alfredforum.com/topic/5334-hammerspoon-workflow/&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;homebrew-and-cask-for-alfred&#34;&gt;Homebrew &amp;amp; Cask for Alfred&lt;/h2&gt;

&lt;p&gt;在alfred中进行mac软件的更新、查看、安装等。&lt;a href=&#34;https://github.com/fniephaus/alfred-homebrew/&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;iterm-sessions&#34;&gt;iTerm Sessions&lt;/h2&gt;

&lt;p&gt;在alfre中快速切换iterm中存在的session窗口。&lt;a href=&#34;https://github.com/madvas/alfred-iterm-sessions&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;kill-process&#34;&gt;Kill Process&lt;/h2&gt;

&lt;p&gt;在alfred中kill进程，有时候程序假死，使用这个很方便，不用再在苹果的菜单栏中点击好几下来操作了。&lt;a href=&#34;https://github.com/nathangreenstein/alfred-process-killer&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;last-changed-files&#34;&gt;Last changed files&lt;/h2&gt;

&lt;p&gt;显示出当前系统最新修改的文件，对于系统有什么修改一目了然。&lt;/p&gt;

&lt;h2 id=&#34;launcher&#34;&gt;Launcher&lt;/h2&gt;

&lt;p&gt;应用程序快速启动workflow，结束Karabiner使用。&lt;/p&gt;

&lt;h2 id=&#34;learn-anything&#34;&gt;Learn Anything&lt;/h2&gt;

&lt;p&gt;Nivita的Learn Anything，只为学习更多。&lt;a href=&#34;https://github.com/nikitavoloboev/alfred-learn-anything&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux-command&#34;&gt;Linux Command&lt;/h2&gt;

&lt;p&gt;Linux命令手册，快速查询linux命令。&lt;a href=&#34;https://github.com/jaywcjlove/linux-command&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mail-dot-app-search&#34;&gt;Mail.app Search&lt;/h2&gt;

&lt;p&gt;快速搜索Mail.app中的邮件信息。可以根据邮件名，发送人，主题等进行搜索。&lt;a href=&#34;http://www.packal.org/workflow/mailapp-search&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;myip&#34;&gt;MyIP&lt;/h2&gt;

&lt;p&gt;快速的查询本机的ip，包括本地IP与外网IP。&lt;/p&gt;

&lt;h2 id=&#34;menubar-search&#34;&gt;MenuBar Search&lt;/h2&gt;

&lt;p&gt;快速查询当前应用的菜单信息，点击进行操作。&lt;/p&gt;

&lt;h2 id=&#34;nsc&#34;&gt;NSC&lt;/h2&gt;

&lt;p&gt;各种进制的转换，支持二进制、十进制、十六进制之间的快速转换。&lt;a href=&#34;https://github.com/obstschale/NSC&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;org-mode-capture&#34;&gt;org-mode-capture&lt;/h2&gt;

&lt;p&gt;快速插入Org capture，可以快速的记录TODO事件。&lt;a href=&#34;https://github.com/alexandergogl/alfred-org-mode-workflow&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;packal-search&#34;&gt;Packal Search&lt;/h2&gt;

&lt;p&gt;Alfred workflow的快速搜索、更新。&lt;a href=&#34;https://github.com/deanishe/alfred-packal-search&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;recent-documents-apps&#34;&gt;Recent Documents / Apps&lt;/h2&gt;

&lt;p&gt;显示当前的文档信息，当前的app信息，当前app关联的文档信息。&lt;a href=&#34;https://github.com/mpco/Alfred3-workflow-recent-documents&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;search-safari-and-chrome-tabs&#34;&gt;Search Safari and Chrome Tabs&lt;/h2&gt;

&lt;p&gt;搜索Chrome和Safari当前打开的tab页面，支持跳转到选择页面。&lt;a href=&#34;http://www.packal.org/workflow/search-safari-and-chrome-tabs&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;searchio&#34;&gt;Searchio!&lt;/h2&gt;

&lt;p&gt;支持google、youtuebe、wiki的fuzzy搜索，支持配置多种语言。&lt;a href=&#34;https://github.com/deanishe/alfred-searchio&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ssh-securecrt&#34;&gt;SSH SecureCRT&lt;/h2&gt;

&lt;p&gt;在alfre快速连接SecureCRT的session。&lt;/p&gt;

&lt;h2 id=&#34;stackoverflow&#34;&gt;StackOverflow&lt;/h2&gt;

&lt;p&gt;搜索stackoverflow上的指定问题。&lt;a href=&#34;https://github.com/deanishe/alfred-stackoverflow&#34;&gt;插件地址(deanishe)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;swift-window-switcher&#34;&gt;Swift Window Switcher&lt;/h2&gt;

&lt;p&gt;使用alfred来快速切换应用的窗口，还可以对safari的当前标签进行搜索。&lt;a href=&#34;https://github.com/mandrigin/AlfredSwitchWindows&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;switchhosts&#34;&gt;SwitchHosts!&lt;/h2&gt;

&lt;p&gt;在alfred中快速本地host的配置，配合&lt;a href=&#34;https://github.com/oldj/SwitchHosts&#34;&gt;SwitchHosts&lt;/a&gt;来使用。&lt;a href=&#34;http://www.packal.org/workflow/switchhosts&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;snippetslab&#34;&gt;SnippetsLab&lt;/h2&gt;

&lt;p&gt;在alfred中快速查看SnippetsLab中的代码片断&lt;/p&gt;

&lt;h2 id=&#34;tldr&#34;&gt;Tldr&lt;/h2&gt;

&lt;p&gt;Tldr的alfred版本，快速查询命令。&lt;a href=&#34;https://github.com/cs1707/tldr-alfred&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;uninstall-with-cleanmymac-x&#34;&gt;Uninstall with CleanMyMac X&lt;/h2&gt;

&lt;p&gt;使用CleanMyMac来快速卸载软件。&lt;a href=&#34;http://www.packal.org/workflow/uninstall-cleanmymac-x&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;vagrantup&#34;&gt;VagrantUP&lt;/h2&gt;

&lt;p&gt;控制vagrant的workflow，可以显示vagrant的环境，根据name，path进行过滤等。&lt;a href=&#34;https://github.com/m1keil/alfred-vagrant-workflow&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;vmware-control&#34;&gt;VMWare Control&lt;/h2&gt;

&lt;p&gt;在alfred中控制vmware虚拟机。支持启动、停止、挂起、切换等操作。&lt;a href=&#34;http://www.packal.org/workflow/vmware-control&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;web-searches&#34;&gt;Web Searches&lt;/h2&gt;

&lt;p&gt;通用的web搜索，支持reddit，google translate等网站搜索。&lt;a href=&#34;https://github.com/nikitavoloboev/alfred-web-searches&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wechat-plugin&#34;&gt;WeChat Plugin&lt;/h2&gt;

&lt;p&gt;在alfred中进行微信聊天，可以显示聊天记录，超级方便。&lt;a href=&#34;https://github.com/TKkk-iOSer/WeChatPlugin-MacOS&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wi-fi&#34;&gt;Wi-Fi&lt;/h2&gt;

&lt;p&gt;控制Mac的ip开关，新更新的版本增加了重启wifi的功能。&lt;a href=&#34;https://github.com/ravelll/wifi-workflow&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;youdao-translate&#34;&gt;Youdao Translate&lt;/h2&gt;

&lt;p&gt;有道词典快速查询翻译，支持中英互译，发音，记录查询历史等功能。&lt;a href=&#34;https://github.com/Rouwanzi/AlfredWorkflow_YoudaoTranslate&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;zapier-for-alfred&#34;&gt;Zapier for Alfred&lt;/h2&gt;

&lt;p&gt;在alfred中触发zapier流，目前还在尝试中。&lt;a href=&#34;https://github.com/zapier/Zapier-for-Alfred/&#34;&gt;插件地址&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>那些提高效率的Idea插件</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ideacha-jian/</link>
      <pubDate>Wed, 05 Sep 2018 08:12:23 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ideacha-jian/</guid>
      
        <description>

&lt;h2 id=&#34;dot-ignore&#34;&gt;.ignore&lt;/h2&gt;

&lt;h3 id=&#34;插件说明&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;ignore文件忽略，支持绝大多数的开发语言，支持直接导航到忽略的文件，在创建时可以选择模板，比如Java开发可以选择Java与Idea选项来生成忽略target文件与.idea文件等的忽略规则。&lt;/p&gt;

&lt;h3 id=&#34;项目地址&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hsz/idea-gitignore&#34;&gt;https://github.com/hsz/idea-gitignore&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ideavim&#34;&gt;IdeaVim&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-1&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;在Idea中使用vi键位来进行编码操作,可以很高的提高效率,插件支持自定义键位来对Idea的action来进行定制,程序员可以根据自己的编程习惯来定制出一个键盘流来.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-1&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/JetBrains/ideavim&#34;&gt;https://github.com/JetBrains/ideavim&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;emacsideas&#34;&gt;emacsIDEAs&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-2&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;支持一些Emacs操作的Idea插件,主要是一些复制,移动,替换,跳转的快捷操作,目前使用最多的是快速查找替换.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-2&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/whunmr/emacsIDEAs&#34;&gt;https://github.com/whunmr/emacsIDEAs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;custom-postfix-templates&#34;&gt;Custom Postfix Templates&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-3&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Idea中非常高效的就是postfix，但是系统自带不可以进行增加，这个插件就可以让用户可以自定义一些高级的postfix语句来提高效率。&lt;/p&gt;

&lt;h3 id=&#34;项目地址-3&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xylo/intellij-postfix-templates&#34;&gt;https://github.com/xylo/intellij-postfix-templates&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jrebel&#34;&gt;Jrebel&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-4&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;动态部署代码插件,可以在不重启Tomcat的情况下进行代码的热部署，提高开发效率没得说。先前可以使用twitter号来免费使用，现在不行，需要自行购买了。&lt;/p&gt;

&lt;h3 id=&#34;项目地址-4&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zeroturnaround.com/software/jrebel/&#34;&gt;https://zeroturnaround.com/software/jrebel/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;camelcase&#34;&gt;CamelCase&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-5&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;文本驼峰规则快速转换，支持从CamelCase-&amp;gt;camelCaase-&amp;gt;camel_case-&amp;gt;camel-case-&amp;gt;CAMEL_CASE的顺序转换，idea中只支持全部大写与全部小写的转换.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-5&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7160-camelcase&#34;&gt;https://plugins.jetbrains.com/plugin/7160-camelcase&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;codehelper&#34;&gt;Codehelper&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-6&#34;&gt;插件说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;代码自动生成插件，支持根据Pojo名来生成dao,mapper,xml等文件，目前使用较少&lt;/li&gt;
&lt;li&gt;生成实体类的setter方法，使用频率高，主要是生成类的setter方法，配合F2查找下一个错误而使焦点至上而下，操作起来非常顺畅。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;项目地址-6&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zhengjunbase/codehelper.generator&#34;&gt;https://github.com/zhengjunbase/codehelper.generator&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;translation&#34;&gt;Translation&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-7&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Idea中集成翻译功能,目前支持有道和goolge,百度翻译.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-7&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/izhangzhihao/intellij-rainbow-brackets&#34;&gt;https://github.com/izhangzhihao/intellij-rainbow-brackets&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;clock&#34;&gt;Clock&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-8&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;当你全屏投入工作时，想知道当前的时间，需要切换出全屏模式，这样就打乱了节奏，这个插件可以在Idea的右下方显示出当前的时间信息，非常实用。&lt;/p&gt;

&lt;h3 id=&#34;插件地址&#34;&gt;插件地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/amolenaar/idea-clock&#34;&gt;https://github.com/amolenaar/idea-clock&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;dash&#34;&gt;Dash&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-9&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Dash是一个mac上的开发文档查询工具,Idea Dash这个插件使得开发者可以直接通过快捷键来调用Dash工具进行文档的查询.目前这个插件提供了对Dash,Velocity,Zeald三种工具的支持.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-8&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gdelmas/IntelliJDashPlugin&#34;&gt;https://github.com/gdelmas/IntelliJDashPlugin&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rainbow-brackets&#34;&gt;Rainbow Brackets&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-10&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;让Idea的括号更好看，对于对应的括号(标签)会显示相同的颜色，特别对于编写html时的标签对应，一眼就可以看出来标签是不是对应出现的。&lt;/p&gt;

&lt;h3 id=&#34;项目地址-9&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/izhangzhihao/intellij-rainbow-brackets&#34;&gt;https://github.com/izhangzhihao/intellij-rainbow-brackets&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;restfultoolkit&#34;&gt;RestfulToolkit&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-11&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;此项目可以快速查询Springmvc项目中Controller的Mapping定义，即根据url来跳转方法定义，在原有Idea的按类、按文件、按方法名查找功能上增添新的查找功能。非常好用。&lt;/p&gt;

&lt;h3 id=&#34;项目地址-10&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/10292-restfultoolkit&#34;&gt;https://plugins.jetbrains.com/plugin/10292-restfultoolkit&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;duplicate-lines&#34;&gt;Duplicate Lines&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-12&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;这是一个快速复制行内容的插件,Idea默认也是支持复制行的操作,当你选中了括号中的文字时再想进行复制编辑时这个插件就可以发挥作用了,它会复制行的内容,并将光标置于被复制行时选中的字符上,这样就可以接着进行复制后的修改操作了.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-11&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xusoo/duplicate-lines-intellij-plugin&#34;&gt;https://github.com/xusoo/duplicate-lines-intellij-plugin&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;findbugs&#34;&gt;FindBugs&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-13&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;静态代码bug查找工具,帮程序员在编写时发现一些错误的代码问题,支持200多个分析规则.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-12&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://andrepdo.github.io/findbugs-idea/&#34;&gt;http://andrepdo.github.io/findbugs-idea/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;gittoolbox&#34;&gt;GitToolBox&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-14&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;对原有idea中内置的git插件的补充，可以在状态栏显示当前光标所在行的修改者&lt;/p&gt;

&lt;h3 id=&#34;插件地址-1&#34;&gt;插件地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zielu/GitToolBox&#34;&gt;https://github.com/zielu/GitToolBox&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hidpi&#34;&gt;Hidpi&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-15&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;根据idea所在的监控器的分辨率来使用指定的idea配置，比加在分辨率高的显示器使用字号大的配置。&lt;/p&gt;

&lt;h3 id=&#34;插件地址-2&#34;&gt;插件地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mskonovalov/intellij-hidpi-profiles&#34;&gt;https://github.com/mskonovalov/intellij-hidpi-profiles&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;json-viewer&#34;&gt;JSON Viewer&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-16&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;在Idea中进行json的格式化与查看工具.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-13&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/potterhsu/JsonViewer&#34;&gt;https://github.com/potterhsu/JsonViewer&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;json2java4idea&#34;&gt;Json2Java4Idea&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-17&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;根据Json数据来生成Java类的工具,支持Jackson,Json,Moshi.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-14&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/t28hub/json2java4idea&#34;&gt;https://github.com/t28hub/json2java4idea&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;liveplugin&#34;&gt;LivePlugin&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-18&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;在不重启Idea情况下来编写Idea插件,可以编写一些小的功能插件.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-15&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dkandalov/live-plugin&#34;&gt;https://github.com/dkandalov/live-plugin&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lombok&#34;&gt;Lombok&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-19&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://projectlombok.org/&#34;&gt;Lombox&lt;/a&gt;的Idea插件,使用注释的方式来快速处理getter和setter,当然功能不止这些.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-16&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mplushnikov/lombok-intellij-plugin&#34;&gt;https://github.com/mplushnikov/lombok-intellij-plugin&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;missing-in-actions&#34;&gt;Missing In Actions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vsch/MissingInActions&#34;&gt;Missing In Actions&lt;/a&gt;，增强的action，带来了Idea Action缺少的增强动作，如移动语句自动缩进、剪切历史增强中等功能。&lt;/p&gt;

&lt;h2 id=&#34;plantuml&#34;&gt;PlantUML&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-20&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;在Idea中进行uml图的处理.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-17&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/esteinberg/plantuml4idea&#34;&gt;https://github.com/esteinberg/plantuml4idea&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pojo-to-json&#34;&gt;POJO to JSON&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-21&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Java类型转成JSON,方便用postman或者curl的时候构造JSON body.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-18&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/9686-pojo-to-json&#34;&gt;https://plugins.jetbrains.com/plugin/9686-pojo-to-json&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;save-actions&#34;&gt;Save Actions&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-22&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Idea的保存动作的执行插件,支持在保存后执行一些命令,比如重新导入包,格式化代码,重新整理代码等.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-19&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dubreuia/intellij-plugin-save-actions&#34;&gt;https://github.com/dubreuia/intellij-plugin-save-actions&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;spring-assistant&#34;&gt;Spring Assistant&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-23&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Springboot配置文件编写助手,在编写些插件会给出一些提示,帮助开发者可以更快速的进行配置.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-20&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/1tontech/intellij-spring-assistant&#34;&gt;https://github.com/1tontech/intellij-spring-assistant&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;string-mainpulatin&#34;&gt;String Mainpulatin&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-24&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;String字符操作插件,支持CamelCase插件的功能,另外还支持Encode,Decode,对齐,trim等操作,功能很强大.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-21&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/krasa/StringManipulation&#34;&gt;https://github.com/krasa/StringManipulation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;testme&#34;&gt;TestMe&lt;/h2&gt;

&lt;h3 id=&#34;插件说明-25&#34;&gt;插件说明&lt;/h3&gt;

&lt;p&gt;Junit等测试工具的生成插件,支持Junit4/5,TestNG,Spock等测试框架代码的生成.&lt;/p&gt;

&lt;h3 id=&#34;项目地址-22&#34;&gt;项目地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wrdv/testme-idea&#34;&gt;https://github.com/wrdv/testme-idea&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;goto-stackoverflow&#34;&gt;Goto Stackoverflow&lt;/h2&gt;

&lt;p&gt;在idea中选中文本在右键中进行基于stackoverflow网站的google搜索。&lt;a href=&#34;https://github.com/gejun123456/IntellijGoToStackOverFlow&#34;&gt;https://github.com/gejun123456/IntellijGoToStackOverFlow&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;show-as&#34;&gt;Show as&lt;/h2&gt;

&lt;p&gt;在调试时,显示一个&amp;rdquo;show as&amp;rdquo;的菜单显示变量值的格式化信息。&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7010-show-as--&#34;&gt;https://plugins.jetbrains.com/plugin/7010-show-as--&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;branch-in-window-title&#34;&gt;Branch in Window Title&lt;/h2&gt;

&lt;p&gt;在Idea的window中显示当前git项目的分支名，可以使用window操作软件进行编程自动化。&lt;a href=&#34;https://github.com/tom-haines/branch-window-title/&#34;&gt;https://github.com/tom-haines/branch-window-title/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;frame-switcher&#34;&gt;Frame Switcher&lt;/h2&gt;

&lt;p&gt;打开了多个project，找不到哪个项目，来回切换太麻烦，来用Frame Switcher吧。&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7138-frame-switcher/&#34;&gt;https://plugins.jetbrains.com/plugin/7138-frame-switcher/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;actions-tree&#34;&gt;Actions tree&lt;/h2&gt;

&lt;p&gt;类似Emacs的操作列表树，Ctrl+c 回来了。&lt;a href=&#34;https://gitlab.com/lae/intellij-actions-tree&#34;&gt;https://gitlab.com/lae/intellij-actions-tree&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之代理模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dai-li-mo-shi/</link>
      <pubDate>Mon, 16 Jul 2018 21:08:28 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dai-li-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;代理模式是设计模式中使用频率非常的高的模式，像日常生活中的房产中介、外卖平台都属于代理。代理模式就是在访问真正的业务之时不会直接与真正的业务进行调用，而是与一个与真正业务对象有着相同功能声明的代理来进行处理，但是最终的处理还是由真正的业务类来进行（决定），比如房产中介，他们会帮助找房者根据条件来对可选房屋进行筛选，但是最终订与不订的权利还是由找房者来决定。常见的代理有保护代理、虚拟代理、远程代理。&lt;/p&gt;

&lt;h2 id=&#34;代理模式&#34;&gt;代理模式&lt;/h2&gt;

&lt;p&gt;我们常用的后台系统一般会根据用户权限的不同对用户展示不同的业务菜单，拥有高权限的人会展示相对多的菜单进行操作，在这个过程中还要记录用户的操作日志，用户点了什么，执行了什么操作都需要进行记录，达到有据可查。在这个业务场景下，就可以使用代理模式进行实现。代理对象会持有一个真正业务对象的实例，在代理对象中还引用日志服务与权限服务，所有的请求都经过这个代理类来进行，这样就可以根据操作的用户的状态来进行相应的处理了。具体的代码实现如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义一个查询接口，在这里定义一个查询用户收入的方法，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.proxy;

/**
* Created by tomyli on 2018/6/28.
* Github: https://github.com/peng051410
*/
public interface Search {

void queryIncome(String username);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再定义一个实现该接口的具体业务类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.proxy;

/**
* Created by tomyli on 2018/6/28.
* Github: https://github.com/peng051410
*/
public class SearchService implements Search {

@Override
public void queryIncome(String username) {

    System.out.println(username + &amp;quot;开始查询&amp;quot;);

    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println(username + &amp;quot;查询完成&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上面代码中就实现了查询收入的方法，简单的打印了两行日志。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于在实现需要对权限进行控制并记录日志，则先把需要用来的权限类与日志类进行定义与实现。实现代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.proxy;

/**
* Created by tomyli on 2018/6/28.
* Github: https://github.com/peng051410
*/
public class Auth {

public boolean valid(String username) {

    return &amp;quot;admin&amp;quot;.equals(username);
}
}


public class Logger {

public void beforeLog(String username) {
    System.out.println(&amp;quot;开始记录&amp;quot; + username + &amp;quot;查询日志&amp;quot;);
}

public void afterLog(String username) {
    System.out.println(&amp;quot;结束记录&amp;quot; + username + &amp;quot;查询日志&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后来进行代理类的实现，代理类通常也会实现查询接口，这样在调用者看来它与真正的业务类没有什么区别，实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.proxy;

/**
* Created by tomyli on 2018/6/28.
* Github: https://github.com/peng051410
*/
public class SearchProxy implements Search {

private Logger logger = new Logger();
private Auth auth = new Auth();
private Search search = new SearchService();

@Override
public void queryIncome(String username) {

    logger.beforeLog(username);
    if (auth.valid(username)) {
        search.queryIncome(username);
    }
    logger.afterLog(username);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上面的代理中，它维护了权限与日志这两个工具类的实例，还维护真正提供查询的业务类实例，在实现的查询收入接口中，先进行进入日志的记录，再验证用户的权限，验证通过则调用真正的业务类来查询收入，最后记录结束的日志，一次调用处理完成。
上面实现的类图如下：


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/proxy.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/proxy.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;

主要的核心都在代理类中，它对整个的流程进行全面的控制，对真正的业务方法进行了保护，只有满足条件的请求才可以被处理。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;代理模式使得具体的业务方法在不想过多的暴露自己的情况更好的保护了具体业务，很好的隔离了调用者与被调用者，降低了系统的耦合性。&lt;/li&gt;
&lt;li&gt;对真正业务的修改对调用者是无感知的，它们只需要与代理打交道就可以，符合开闭原则。&lt;/li&gt;
&lt;li&gt;保护代理可以对访问进行细粒度的控制。&lt;/li&gt;
&lt;li&gt;对于虚拟代理可以对于耗费资源的大对象进行一个简单代理，在用户使用再调用时真正的对象已经实例化完毕，给了用户更好的体验。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;由于在中间增加了代理，多了一些额外的处理，对于处理速度会有一定的降低。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之委托模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-wei-tuo-mo-shi/</link>
      <pubDate>Sat, 07 Jul 2018 18:53:57 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-wei-tuo-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;委托模式不属于23种设计模式中，但是它在Spring框架中使用的很频繁，Spring的作用在Java的开发是非常大，所以需要学习一下委托模式。委托模式是指两个对象都有相同的方法与功能，比如A、B两个对象都有相同的方法，但是有调用A的method方法，A不会自己来处理而是直接调用了B的同名方法，由两个对象参与同一个请求，接受请求的对象将委托给另一个对象来处理。&lt;/p&gt;

&lt;h2 id=&#34;委托模式&#34;&gt;委托模式&lt;/h2&gt;

&lt;p&gt;在一般的公司中，都会分为老板、项目经理、开发人员结构，老板负责制定决策，分配给项目经理后，他不会自己来完成，而是把需要的功能进行分解，交给擅长的开发人员进行实现。虽然项目经理也可以完成，但是是他把这些事情委托给了多个开发人员来做，加快了完成任务的速度。就以这个需求来说，使用委托模式来进行实现:&lt;/p&gt;

&lt;p&gt;定义抽象的人类接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.delegate;

/**
 * Created by tomyli on 2018/6/27.
 * Github: https://github.com/peng051410
 */
public interface Member {

    void showName();

    void showSkill();

    void doWork();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中定义了抽象的人类接口，显示这个人的名字，拥有的技能，工作的状态情况，接下来实现需求中的每个人。&lt;/p&gt;

&lt;p&gt;定义老板(BOSS):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.delegate;

/**
 * Created by tomyli on 2018/6/27.
 * Github: https://github.com/peng051410
 */
public class Boss implements Member {

    @Override
    public void showName() {
        System.out.println(&amp;quot;i am boss&amp;quot;);
    }

    @Override
    public void showSkill() {
        System.out.println(&amp;quot;send commend&amp;quot;);
    }

    @Override
    public void doWork() {
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义项目经理和员工:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.delegate;

/**
 * Created by tomyli on 2018/6/27.
 * Github: https://github.com/peng051410
 */
public class Leader implements Member {

    private Member developerA;
    private Member developerB;

    public void setDeveloperA(Member developerA) {
        this.developerA = developerA;
    }

    public void setDeveloperB(Member developerB) {
        this.developerB = developerB;
    }

    @Override
    public void showName() {
        System.out.println(&amp;quot;i am leader&amp;quot;);
    }

    @Override
    public void showSkill() {

        showName();
        System.out.println(&amp;quot;i want to select member to doWork&amp;quot;);
    }

    public void doWork(){
        showSkill();
        developerA.doWork();
        developerB.doWork();
    }
}

public class DeveloperA implements Member {

    @Override
    public void showName() {
        System.out.println(&amp;quot;i am developer a&amp;quot;);
    }

    @Override
    public void showSkill() {
        showName();
        System.out.println(&amp;quot;i can do login function&amp;quot;);
    }

    public void doWork() {
        showSkill();
        System.out.println(&amp;quot;start work login&amp;quot;);
    }
}

public class DeveloperB implements Member {

    @Override
    public void showName() {
        System.out.println(&amp;quot;i am developer b&amp;quot;);
    }

    @Override
    public void showSkill() {
        showName();
        System.out.println(&amp;quot;i can do pay function&amp;quot;);
    }

    public void doWork() {
        showSkill();
        System.out.println(&amp;quot;start do pay&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面代码中，定义一个项目经理与两个开发，在项目经理中维护(管理)着对两个开发的引用。这样在项目经理的doWork中其实是调用开发者A与开发者B的doWork来都完成工作。接下来测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.delegate;

/**
 * Created by tomyli on 2018/6/27.
 * Github: https://github.com/peng051410
 */
public class WorkTest {

    public static void main(String[] args) {

        Boss boss = new Boss();
        boss.showName();
        boss.showSkill();

        Leader leader = new Leader();
        Member memberA = new DeveloperA();
        Member memberB = new DeveloperB();

        leader.setDeveloperA(memberA);
        leader.setDeveloperB(memberB);

        leader.doWork();

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BOSS下发了一个工作，由项目经理选择要真正来工作的人，最后调用了项目经理的doWork方法来实现需求，其实是DeveloperA与DeveloperB在真正的工作，对于BOSS而言，他不在乎谁在工作，他只要结果，结果导向嘛。。。苦了我们这帮程序员。&lt;/p&gt;

&lt;p&gt;整体的类图结构:


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/delegate.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/delegate.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;委托模式定义了实现功能的窗口，对于具体的实现由谁实现对于调用者是无感知的，对外提供方换了内部的实现对于调用方无影响。最大限度的实现了解耦&lt;/li&gt;
&lt;li&gt;委托方的功能简单通用，可以在绝大情况下通用，在框架中使用非常适合，可以实现分层解耦&lt;/li&gt;
&lt;li&gt;委托模式使用我们可以使用组合来代替继承&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之观察者</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-guan-cha-zhe/</link>
      <pubDate>Wed, 04 Jul 2018 20:31:41 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-guan-cha-zhe/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;观察者模式在日常开发中使用频率也是非常高的，它建立了对象与对象之间的关系，一个对象的行为改变会通知到另一个对象，被通知的对象根据通知做出相应的处理动作。在观察者中分为目标对象（被观察者）、观察者。观察者模式是一种对象行为模式。&lt;/p&gt;

&lt;h2 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h2&gt;

&lt;p&gt;现在很多人都购买股票，在市面上有很多的股票软件供广大股民使用。股票软件一般会在用户关注的股票有变动时发送消息来通知股民。在这里，某一支股票就是目标对象，广大股民与股票软件就是观察者，他们根据股票的行情变化来做出相应买入或者卖出操作。这一需求可以使用观察者模式进行实现。代码如下：&lt;/p&gt;

&lt;p&gt;先来定义一个抽象的购买股票的股民们，他们有喜有悲的心情:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.observer.stock;

/**
 * Created by tomyli on 2018/6/23.
 * Github: https://github.com/peng051410
 */
public interface Buyer {

    void setName(String name);

    String getName();

    void happy();

    void sad();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来定义具体的股民行为实现类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.observer.stock;

/**
 * Created by tomyli on 2018/6/23.
 * Github: https://github.com/peng051410
 */
public class ConcrectBuyer implements Buyer {

    private String name;

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void happy() {
        System.out.println(this.getName() + &amp;quot;:happy&amp;quot;);
    }

    @Override
    public void sad() {
        System.out.println(this.getName() + &amp;quot;:sad&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的股民实现了喜与悲的方法，这样观察者已经准备就绪。下面来定义股票软件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.observer.stock;

/**
 * Created by tomyli on 2018/6/23.
 * Github: https://github.com/peng051410
 */
public interface StockSoft {

    void goUp();

    void goDown();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个抽象的股票软件，它有两个方法，一个股票上涨，一个是股票下跌。接下来实现具体的股票软件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.observer.stock;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by tomyli on 2018/6/23.
 * Github: https://github.com/peng051410
 */
public class ConcreteStockSoft implements StockSoft {

    private List&amp;lt;Buyer&amp;gt; buyerList;

    public ConcreteStockSoft() {
        this.buyerList = new ArrayList&amp;lt;&amp;gt;();
    }

    public void join(Buyer buyer) {
        buyerList.add(buyer);
    }

    public void quit(Buyer buyer) {
        buyerList.remove(buyer);
    }

    @Override
    public void goUp() {
        buyerList.forEach(Buyer::happy);
    }

    @Override
    public void goDown() {
        buyerList.forEach(Buyer::sad);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个具体的股票软件，它持有一个购买指定股票的股民列表，还有股民加入与退出的方法，实现了股票上涨时的方法，在上涨时会通知股民，调用股民的happy方法，在股票下跌时调用股民的sad方法。接着做一下测试:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.observer.stock;

/**
 * Created by tomyli on 2018/6/23.
 * Github: https://github.com/peng051410
 */
public class StockTest {

    public static void main(String[] args) {

        ConcreteStockSoft niuStock = new ConcreteStockSoft();

        ConcrectBuyer buyer1, buyer2, buyer3;
        buyer1 = new ConcrectBuyer();
        buyer1.setName(&amp;quot;buyer1&amp;quot;);
        buyer2 = new ConcrectBuyer();
        buyer2.setName(&amp;quot;buyer2&amp;quot;);
        buyer3 = new ConcrectBuyer();
        buyer3.setName(&amp;quot;buyer3&amp;quot;);

        niuStock.join(buyer1);
        niuStock.join(buyer2);
        niuStock.join(buyer3);

        niuStock.goUp();

        niuStock.quit(buyer1);
        niuStock.goDown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在测试类中定义了三位购买股票的股民，股票软件把他们加入到维护的股民列表中，这时股票软件发现股票涨了，就调用goUp方法通知了列表中购买股票的股民们。接着股民1选择了卖出股票，则他在软件的维护列表中被移除，这时股票软件发现股票跌了，此时再一次通知持有股票的股民们，这时股民1已经收不到任何的通知，因为他已经不股票软件的通知列表中，此时只股民2与股民3在那悲伤中&amp;hellip;&lt;/p&gt;

&lt;p&gt;实现的观察者模式的类图：


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/observer.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/observer.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;

表面上看股票软件与股民没有任何关系，但是在具体股票软件中维护了股民的列表(buyList)，这样可以在软件发现有变化时调用股民的方法来进行通知。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;观察者模式在观察者与目标对象之间建立了抽象的耦合，目标对象要维护观察者列表，而无须关心具体的观察者。可以更好的进行抽象。&lt;/li&gt;
&lt;li&gt;对目标对象增加观察者无须修改原代码，只需要调用现有的方法就可以，符合开闭原则。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在观察者很多的时候，目标对象发生变化时会消耗很长的时间来通知观察者。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之装饰器</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/</link>
      <pubDate>Mon, 02 Jul 2018 20:09:14 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;装饰器设计模式是使用比较频繁的设计模式，它在不改变原物体的情况对原物体实现了功能的增加，原物体还是一个可单独使用的个体。在JAVA的类库中应该会马上想到IO类，各种的InputStrem，OutputStrem。&lt;/p&gt;

&lt;h2 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h2&gt;

&lt;p&gt;在用户登录的中过程，我们需要对用户输入的密码进行加密操作，在设计时会提供好多种加密的算法，例如简单的BASE64加密，复杂的如MD5、DSA加密。直接把用户的密码存入数据库是真的在耍流氓。在使用这些算法时，我们想灵活的使用，比如使用完简单加密还可以再进行一下MD5的加密。针对这样的需求，可以使用装饰器模式进行实现。大体思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加密接口，定义加密方法。&lt;/li&gt;
&lt;li&gt;在装饰器中，最原始的被装饰者是目标实现，它们一般会实现加密定义的具体方法。&lt;/li&gt;
&lt;li&gt;装饰者会针对目标对象进行装饰，所以它要同样实现加密接口的方法，一般情况下这个装饰器会定义为抽象的形式，在这个装饰器父类中维护着对目标对象的引用。&lt;/li&gt;
&lt;li&gt;具体装饰器继承抽象装饰器来实现对目标对象的真正装饰操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上的情况在代码上体现为如下形式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加密接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.decorator.encrypt;

/**
* Created by tomyli on 2018/6/25.
* Github: https://github.com/peng051410
*/
public interface Encryptor {

void encrypt();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体加密类，实现加密处理接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.decorator.encrypt;

/**
* Created by tomyli on 2018/6/25.
* Github: https://github.com/peng051410
*/
public class ConcreteEncryptor implements Encryptor {

@Override
public void encrypt() {
    System.out.println(&amp;quot;base encrypt!&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;抽象加密装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.decorator.encrypt;

/**
* Created by tomyli on 2018/6/25.
* Github: https://github.com/peng051410
*/
public abstract class EncryptDecorator implements Encryptor {

private Encryptor encrypt;

public EncryptDecorator(Encryptor encrypt) {
    this.encrypt = encrypt;
}

@Override
public void encrypt() {
    encrypt.encrypt();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的抽象装饰器实现的加密接口，在这个类中维护加密接口的实体，加密方法直接调用其维护实体的加密方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;具体的装饰器实现类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.decorator.encrypt;

/**
* Created by tomyli on 2018/6/25.
* Github: https://github.com/peng051410
*/
public class ModEncryptDecorator extends EncryptDecorator {

public ModEncryptDecorator(Encryptor encrypt) {
    super(encrypt);
}

@Override
public void encrypt() {
    super.encrypt();
    modEncrypt();
}

public void modEncrypt() {
    System.out.println(&amp;quot;取模加密！&amp;quot;);
}
}


package cn.imcompany.decorator.encrypt;

/**
* Created by tomyli on 2018/6/25.
* Github: https://github.com/peng051410
*/
public class ConverseEncryptDecorator extends EncryptDecorator {

public ConverseEncryptDecorator(Encryptor encrypt) {
    super(encrypt);
}

@Override
public void encrypt() {
    super.encrypt();
    converseEncrypt();
}

public void converseEncrypt() {
    System.out.println(&amp;quot;逆向加密！&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的代码定义了两个具体的装饰器实体，在这两个装饰器类中，加密方法中都调用了父类的加密方法，然后调用了自己实现的加密方法，这样在先前加密的基础上又进行了一次加密。达到了双重加密的效果。让我们来进行一下测试:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.decorator.encrypt;

/**
 * Created by tomyli on 2018/6/25.
 * Github: https://github.com/peng051410
 */
public class EncryptDecoratorTest {

    public static void main(String[] args) {

        Encryptor encryptor = new ConcreteEncryptor();
        //进行一次简单加密
        Encryptor encryptDecorator = new SimpleEncryptDecorator(encryptor);
        encryptDecorator.encrypt();

        //对上一次加密进行二次加密（反转加密）
        ConverseEncryptDecorator converseEncryptDecorator = new ConverseEncryptDecorator(encryptDecorator);
        converseEncryptDecorator.encrypt();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在测试中先进行了一次简单的加密，又在第一次加密的基础上进行了二次加密，如果再想使用第三次加密，直接把二次加密的对象引用传入即可。这样可以形成很多种组合，可以满足很多加密的需求。
上面的加密类的类图如下：


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/decorator.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/decorator.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;针对抽象编程，装饰器可以使多个类的功能进行组合，比继承更加的灵活。&lt;/li&gt;
&lt;li&gt;可以对一个对象进行多次的装饰，可以创造出具有强大功能的类。&lt;/li&gt;
&lt;li&gt;具体的构建类与装饰器分隔，想要增加一个新功能时不需要修改原代码，符合开闭原则。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;增加一个小的功能也需要增加一个类来实现，有些时候会有些浪费。&lt;/li&gt;
&lt;li&gt;由于实现也多重装饰，在出现问题时对于定位问题要一层一层的来处理。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之适配器</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gua-pei-qi/</link>
      <pubDate>Tue, 26 Jun 2018 21:30:17 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gua-pei-qi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;http://blog.imcompany.cn/posts/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi&#34;&gt;前面&lt;/a&gt;的文章中介绍了一些关于支付相关的功能，现在转向登录，在早些时期的系统登录就是用户使用用户名与密码进行注册，注册成功后就可以进行登录了。随着时代的发展，出现很多三方的平台，它们对外提供了获取平台用户信息的功能，例如微信、qq、微博等三方登录，在接入这些三方登录时都是遵循相应的规则，老的登录的方式需要保留，对接新的登录方式还想要使用老的登录服务，这样可以使用适配器模式来实现。&lt;/p&gt;

&lt;h2 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h2&gt;

&lt;p&gt;比如我们平常使用的转接头一样，就是一种适配器的模式。它使两个不相关的物体很好的关联在一起。对于要接入的新的登录方式，首先定义新的三方登录的接口，定义要使用的三方登录方式，如下代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.adapter;

/**
 * Created by tomyli on 2018/6/22.
 * Github: https://github.com/peng051410
 */
public interface ThirdLogin {

    void wechatLogin(String accessToken);

    void qqLogin(String accessToken);

    void sinaLogin(String accessToken);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上定义了微信、qq、微博三种登录方式，它们都是使用accessToken来进行认证，经用户同意后获取相应的用户的信息调用方使用。下面来进行具体的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.adapter;

/**
 * Created by tomyli on 2018/6/22.
 * Github: https://github.com/peng051410
 */
public class ThirdLoginAdapter implements ThirdLogin {

    private LoginService loginService;

    public ThirdLoginAdapter() {
        this.loginService = new LoginService();
    }

    @Override
    public void wechatLogin(String accessToken) {

        System.out.println(&amp;quot;微信获取用户信息&amp;quot;);
        loginService.login(accessToken, null);
    }

    @Override
    public void qqLogin(String accessToken) {

        System.out.println(&amp;quot;qq获取用户信息&amp;quot;);
        loginService.login(accessToken, null);
    }

    @Override
    public void sinaLogin(String accessToken) {

        System.out.println(&amp;quot;微博获取用户信息&amp;quot;);
        loginService.login(accessToken, null);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的实现，并没有重新写登录的逻辑，除了要调用三方平台的代码，登录的功能是直接使用老的登录服务实现的。在这个实现类中引用了老的服务，然后使用其已经非常成熟的功能来完成登录的操作。这样以最少的代码达到了新的需求也使老的服务可以正常运行。免去了很多测试的功能点。这种适配器叫做对象适配器。&lt;/p&gt;

&lt;h2 id=&#34;缺省适配器&#34;&gt;缺省适配器&lt;/h2&gt;

&lt;p&gt;上面的登录方法比较简单，如果要适配(实现一个接口)很多的业务方法，则对于实现方是一个困难，如果不想实现所有的方法可以定义一个抽象类来实现接口的大部分方法，再继承这个类选择需要实现覆盖的方法进行处理，这样就得到了一个缺省的适配的模式。对于用户状态一般有性别、是否是VIP等一些标识信息。下面定义了一个用户的基本标识类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.adapter.def;

/**
 * Created by tomyli on 2018/6/22.
 * Github: https://github.com/peng051410
 */
public interface IMemberService {

    void saveMember();

    void getMember();

    boolean isGirl();

    boolean isBoy();

    boolean isVip();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于实现类来不想一下子都实现，因为有些标识可以是默认的，比加默认情况是用户都不是VIP用户，面向男士的应用则默认isBoy返回true。这样可以先定义一个抽象来进行一些基本的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.adapter.def;

/**
 * Created by tomyli on 2018/6/22.
 * Github: https://github.com/peng051410
 */
public abstract class AbstractMemberService implements IMemberService {

    public abstract void saveMember();

    public abstract void getMember();

    @Override
    public boolean isGirl() {
        return false;
    }

    @Override
    public boolean isBoy() {
        return true;
    }

    @Override
    public boolean isVip() {
        return false;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来真正类只需要继承这个抽象类来重写一些特定的方法就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.adapter.def;

/**
 * Created by tomyli on 2018/6/22.
 * Github: https://github.com/peng051410
 */
public class MemberService extends AbstractMemberService {

    @Override
    public void saveMember() {
        System.out.println(&amp;quot;saveMember&amp;quot;);
    }

    @Override
    public void getMember() {
        System.out.println(&amp;quot;getMember&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，MemberService只需要重写saveMember和getMember方法就可以了，其它的三个方法在父类中有了默认的设置，这减少了子类实现方法的数目。缺省适配器属于类适配器，缺省适配器的结构图如下：&lt;/p&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/default-adapter.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/default-adapter.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h2 id=&#34;适配器总结&#34;&gt;适配器总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;适配器模式可以使两个不相关的类进行关联适配。可以重用原代码而且不需要修改原代码。&lt;/li&gt;
&lt;li&gt;增加了类的利用性，代码都封装在了适配器类，可以增加适配者的复用性。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之模板模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi/</link>
      <pubDate>Mon, 25 Jun 2018 21:06:17 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;在一般实现处理用户支付订单时，通常都会在一个单独的回调项目中来处理用户的支付方式回调。一般情况下，回调的处理过程都是相似的，大体的步骤就是获取参数-&amp;gt;验证参数-&amp;gt;验证签名-&amp;gt;验证支付状态（可选）-&amp;gt;订单状态为成功增加用户的充值金额。具体的过程由于不同的支付方式不同而处理的不同。这种需求可以使用模板的模板模式来实现。&lt;/p&gt;

&lt;h2 id=&#34;模板设计模式实现&#34;&gt;模板设计模式实现&lt;/h2&gt;

&lt;p&gt;模板模式就是由一个类来声明整个处理流程的步骤，具体的实现由各个实现类来进行实现。处理的流程不变，变是就是里面具体的实现。针对上面的支付回调，可以声明一个抽象类来声明具体的流程方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.callback;

import java.util.Map;

/**
 * Created by tomyli on 2018/6/21.
 * Github: https://github.com/peng051410
 */
public abstract class PayCallback {

    public abstract Map&amp;lt;String, String&amp;gt; getParam();

    public abstract boolean checkParam(Map&amp;lt;String, String&amp;gt; param);

    public abstract boolean validSign();

    /**
     * 定义了一个钩子方法来让子类控制流程实现
     * @return true：强制返回，false：不强制返回
     */
    public boolean forceReturn() {

        return false;
    }

    public String doService() {

        Map&amp;lt;String, String&amp;gt; map = getParam();
        if (!checkParam(map)) {
            return &amp;quot;param fail&amp;quot;;
        }
        if (!validSign()) {
            return &amp;quot;sign fail&amp;quot;;
        }

        if (!map.get(&amp;quot;status&amp;quot;).equals(&amp;quot;success&amp;quot;)) {
            if (forceReturn()) {
                return &amp;quot;order fail&amp;quot;;
            }
        }

        return &amp;quot;success&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的PayCallback类中声明了getParam(获取参数)，checkParam（验证参数），validSign（验证签名），验证支付状态四个步骤，具体的支付回调类要来实现这里声明的方法即可。下面是一个微信支付的回调类的代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.callback;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by tomyli on 2018/6/21.
 * Github: https://github.com/peng051410
 */
public class WechatPayCallback extends PayCallback {

    @Override
    public Map&amp;lt;String, String&amp;gt; getParam() {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&amp;quot;status&amp;quot;, &amp;quot;fail&amp;quot;);
        return map;
    }

    @Override
    public boolean checkParam(Map&amp;lt;String, String&amp;gt; param) {
        return true;
    }

    @Override
    public boolean validSign() {
        return true;
    }

    @Override
    public boolean forceReturn() {

        return true;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的微信回调类实现了PayCallback类声明的抽象方法，它返回的状态是状态失败，在这里面有一个forceReturn方法，可以处理是否在某一个流程进行强制的返回，在微信回调类里面是进行强制返回，下面看一下支付宝的回调类代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.callback;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by tomyli on 2018/6/21.
 * Github: https://github.com/peng051410
 */
public class AliPayCallback extends PayCallback {

    @Override
    public Map&amp;lt;String, String&amp;gt; getParam() {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&amp;quot;status&amp;quot;, &amp;quot;success&amp;quot;);
        return map;
    }

    @Override
    public boolean checkParam(Map&amp;lt;String, String&amp;gt; param) {
        return true;
    }

    @Override
    public boolean validSign() {
        return true;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于支付宝，这里面的状态是成功，证明这一单处理成功，在支付宝回调这个类里面没有重写父类的forceReturn方法，这个方法子类可以根据需要来决定是否需要覆盖。这样父类给了子类可以控制父类流程的方法，这个方法一般叫做钩子方法，是留给子类来进行一些特殊处理的方法。子类实现这个方法就可以间接的控制父类中定义好的流程。比如在这里就可以控制遇到支付状态为失败的订单是否继续进行后续的操作。不进行了说明这一单也正确处理完成，返回给调用方正确的状态就可以了。&lt;/p&gt;

&lt;h3 id=&#34;模板模式实现的类图&#34;&gt;模板模式实现的类图&lt;/h3&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/template.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/template.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h2 id=&#34;模板模式总结&#34;&gt;模板模式总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;模板模式定义了一个具体的流程来实现功能，子类只需要实现相应定义的方法就可以达到最终的结果。增加另一种回调类也非常的容易，只需要实现父类的方法就可以了。符合开闭原则。&lt;/li&gt;
&lt;li&gt;父类可以提供子类进行流程控制的方法，这样可以实现子类的反向控制。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之策略模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-ce-lue-mo-shi/</link>
      <pubDate>Wed, 20 Jun 2018 07:04:56 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-ce-lue-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;策略模式是设计模式中使用频率很高的模式，主要的就是实现对行为的包装，达到结果的方式有多种，使用者可以选择任何一个方式来得到想要结果，在增加新的方式时更加的方便与灵活。它是为了适应算法的灵活性而产生的。&lt;/p&gt;

&lt;h2 id=&#34;策略模式实现&#34;&gt;策略模式实现&lt;/h2&gt;

&lt;p&gt;以常用的购物为例，一般情况下购物分为浏览商品，下单，支付。在支付时消费者可以选择多种不同的支付方式，如支付宝、微信、京东支付、银联支付等。在支付中流程就可以使用到策略模式，网站为用户提供了这些支付方式可供选择，用户只需要选择自己喜欢的支付方式来进行充值就可以得到商品了。在一般情况下都会定义一个抽象类来定义支付的一些行为，如金额，商品简介等信息。实现的抽象类如以下定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.pay;

/**
 * Created by tomyli on 2018/6/20.
 * Github: https://github.com/peng051410
 */
public interface Payment {

    boolean pay(String param);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就定义了支付方式的行为，剩下的就由不同的支付方式来进行实现，比如支付宝支付、微信支付，示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.pay;

/**
 * Created by tomyli on 2018/6/20.
 * Github: https://github.com/peng051410
 */
public class AliPay implements Payment {

    @Override
    public boolean pay(String param) {

        System.out.println(&amp;quot;AliPay&amp;quot;);
        return true;
    }
}

public class WechatPay implements Payment {

    @Override
    public boolean pay(String param) {

        System.out.println(&amp;quot;WechatPay&amp;quot;);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要是再增加一种支付方式则可以实现Payment接口进行实现就可以了，一般情况下会有一个维护支付方式的常量类，由它来维护可用的支付方式。这个常量类的简化代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.pay;

/**
 * Created by tomyli on 2018/6/20.
 * Github: https://github.com/peng051410
 */
public enum PayType {

    ALI_PAY(new AliPay()),
    WECHAT_PAY(new WechatPay()),
    JD_PAY(new JdPay()),
    UNICOME_PAY(new UnicomePay()),
    ;

    private Payment payment;

    PayType(Payment payment) {
        this.payment = payment;
    }

    public Payment getPayment() {
        return payment;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在常量类可以获取要支付的具体支付方式来进行支付。接下来进行一下测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.pay;

/**
 * Created by tomyli on 2018/6/20.
 * Github: https://github.com/peng051410
 */
public class PayTest {

    public static void main(String[] args) {

        PayType.ALI_PAY.getPayment().pay(&amp;quot;123&amp;quot;);

        PayType.valueOf(PayType.WECHAT_PAY.toString()).getPayment().pay(&amp;quot;325&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的测试会输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AliPay
WechatPay
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个简单的策略模式就实现了。
策略模式的类图如下:


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/strategy.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/strategy.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;策略设计模式总结&#34;&gt;策略设计模式总结&lt;/h2&gt;

&lt;p&gt;策略模式是一种行为类型的设计模式，它封装了不同的行为，给使用者提供几种选择来实现结果。&lt;/p&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;再增加新的支付方式只需要增加实现类即可，不需要修改现在支付方式的实现逻辑。符合开闭原则。&lt;/li&gt;
&lt;li&gt;在选择行为时避免了很多的if-else的判断。使代码更加清晰。&lt;/li&gt;
&lt;li&gt;策略模式提供了统一的管理行为的方式。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;无法一起使用多个策略类。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之工厂模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gong-han-mo-shi/</link>
      <pubDate>Tue, 12 Jun 2018 21:33:40 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gong-han-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;工厂设计模式是23种设计模式中使用频率非常高的，属于创建型模式。主要特点是实现了实体创建与使用的分离，达到了解耦的目的。工厂设计模式一般分为简单工厂、工厂方法、抽象工厂。&lt;/p&gt;

&lt;h2 id=&#34;前提准备&#34;&gt;前提准备&lt;/h2&gt;

&lt;p&gt;4年一界世界杯即将到来，啤酒厂商又要大嫌一笔。我们先准备好要生产的啤酒实体。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany;

/**
 * Created by tomyli on 2018/5/27.
 * Github: https://github.com/peng051410
 */
public interface Beer {

    String getName();
}

public class JinShiBai implements Beer {

    @Override
    public String getName() {
        return &amp;quot;金士百&amp;quot;;
    }
}

public class QingDao implements Beer {

    @Override
    public String getName() {
        return &amp;quot;青岛&amp;quot;;
    }
}

public class BaiWei implements Beer {

    @Override
    public String getName() {
        return &amp;quot;百威&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面定义三种啤酒，它们都由抽象类Beer继承而来。下面使用简单工厂来给消费者提供啤酒。&lt;/p&gt;

&lt;h2 id=&#34;简单工厂&#34;&gt;简单工厂&lt;/h2&gt;

&lt;p&gt;消费者需要不同品类的啤酒，使用简单工厂来实现，代码如下：&lt;/p&gt;

&lt;h3 id=&#34;简单工厂生产啤酒&#34;&gt;简单工厂生产啤酒&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.simple;

import cn.imcompany.BaiWei;
import cn.imcompany.Beer;
import cn.imcompany.JinShiBai;
import cn.imcompany.QingDao;

/**
 * 一个工厂什么都生产,根据传入的参数来返回不同的产品
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public class SimpleFactory {

    public static Beer getBeer(String name) {
        if (&amp;quot;青岛&amp;quot;.equals(name)) {
            return new QingDao();
        } else if (&amp;quot;百威&amp;quot;.equals(name)) {
            return new BaiWei();
        } else if (&amp;quot;金士百&amp;quot;.equals(name)) {
            return new JinShiBai();
        } else {
            System.out.println(&amp;quot;没有这种啤酒&amp;quot;);
            return null;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码简单工厂会根据传入的啤酒名称来生产出不同的啤酒。下面来测试一下这个简单工厂&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.simple;

/**
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public class SimpleFactoryTest {

    public static void main(String[] args) {
        System.out.println(SimpleFactory.getBeer(&amp;quot;青岛&amp;quot;));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在消费者可以喝到青岛牌子的啤酒了。简单工厂实现实体创建与使用的分离。由于简单工厂一般都会提供静态的获取实体的方法，所以它还会被称为静态工厂。&lt;/p&gt;

&lt;h3 id=&#34;简单工厂总结&#34;&gt;简单工厂总结&lt;/h3&gt;

&lt;h4 id=&#34;优点&#34;&gt;优点：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;简单工厂的实现非常简单，把原本由Beer来处理的创建工作给抽离出来，根据传入的参数来进行实体的创建。&lt;/li&gt;
&lt;li&gt;实体的创建完全交给简单工厂来处理，实体什么时候创建对使用者是无感知的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;如果要新增一款啤酒，则要修改工厂类，违反了设计模式中对扩展开放，对修改关闭的原则。&lt;/li&gt;
&lt;li&gt;使用需要记住要使用产品名称，如果传入错误则不会得到正确的结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;工厂方法&#34;&gt;工厂方法&lt;/h2&gt;

&lt;h3 id=&#34;工厂方法生产啤酒&#34;&gt;工厂方法生产啤酒&lt;/h3&gt;

&lt;p&gt;为了解决简单工厂中的问题，我们引入工厂方法，使用工厂方法，则每一款啤酒对应的都会由一个特定的工厂来进行生产，这些工厂统一都继承自一个抽象的工厂，由这个抽象的工厂来定义要生产的产品规范。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 定义获取的功能，具体由实现类（具体的啤酒厂）来实现，做到创建与使用隔离
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public abstract class FunctionFactory {

    public abstract Beer getBeer();

}

public class BaiWeiFactory extends BeerFactory {

    @Override
    public Beer getBeer() {
        return new BaiWei();
    }
}

public class JinShiBaiFactory extends BeerFactory {

    @Override
    public Beer getBeer() {
        return new JinShiBai();
    }
}

public class QinDaoFactory extends BeerFactory {

    @Override
    public Beer getBeer() {
        return new QingDao();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码展示了各种啤酒由不同工厂来生产的情况，每个工厂都继承自BeerFactory这个抽象类，它只定义了生产啤酒这个抽象方法，具体生产什么牌子的啤酒由各个具体工厂来处理。这样在用户使用时就可以指定要哪一家工厂生产的酒就可以了。
下面来测试这种工厂生产的啤酒。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.function;

/**
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public class FunctionFactoryTest {

    public static void main(String[] args) {
        BeerFactory jinShiBaiFactory = new JinShiBaiFactory();
        System.out.println(jinShiBaiFactory.getBeer());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码指定了要用金士百工厂生产的啤酒，实例指向的永远是抽象工厂，这就是所谓的多态，这样我们可以面向抽象来进行编程，而不是面对具体的实现。灵活性与扩展性大大的增加了。&lt;/p&gt;

&lt;h3 id=&#34;工厂方法总结&#34;&gt;工厂方法总结&lt;/h3&gt;

&lt;h4 id=&#34;优点-1&#34;&gt;优点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;使用者不用记住产品的名称了，只要知道要使用哪家的工厂生产的产品就可以了。&lt;/li&gt;
&lt;li&gt;如果再增加一种啤酒，可以直接增加一个工厂来进行生产，不用修改现有工厂的实现，实现了开闭原则。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;类的数目增加了很多，会产生类的膨胀。&lt;/li&gt;
&lt;li&gt;增加一种产品不仅要增加具体的产品类，还要为之提供一个具体的工厂，复杂度增加。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;抽象工厂&#34;&gt;抽象工厂&lt;/h2&gt;

&lt;p&gt;为了解决工厂方法中系统复杂的情况，我们引入抽象工厂，由抽象工厂来定义所要生产的啤酒类型，再由具体的工厂来对这些啤酒进行生产。由于生产的产品都有相似的特征，可以理解为生产一个产品族。&lt;/p&gt;

&lt;h3 id=&#34;抽象工厂生产啤酒&#34;&gt;抽象工厂生产啤酒&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.abs;

import cn.imcompany.Beer;

/**
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public interface AbstractBeerFactory {

    Beer getQingDao();

    Beer getBaiWei();

    Beer getJinShiBai();

}

package cn.imcompany.abs;

import cn.imcompany.BaiWei;
import cn.imcompany.Beer;
import cn.imcompany.JinShiBai;
import cn.imcompany.QingDao;

/**
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public class ConcreteBeerFactory implements AbstractBeerFactory {

    @Override
    public Beer getQingDao() {
        return new QingDao();
    }

    @Override
    public Beer getBaiWei() {
        return new BaiWei();
    }

    @Override
    public Beer getJinShiBai() {
        return new JinShiBai();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次把生产的三种啤酒都定义在一个抽象工厂中，再由一个具体的工厂来实现所要生产啤酒的功能。我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.abs;

/**
 * Created by tomyli on 2018/5/28.
 * Github: https://github.com/peng051410
 */
public class AbstractFactoryTest {

    public static void main(String[] args) {

        AbstractBeerFactory beerFactory = new ConcreteBeerFactory();
        System.out.println(beerFactory.getBaiWei());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在测试类中实例化一个具体的工厂，然后调用工厂中生产具体酒的方法就可以得到正确的商品，使用者无须记住多个工厂，只要一个工厂就可以满足需要。&lt;/p&gt;

&lt;h3 id=&#34;抽象工厂总结&#34;&gt;抽象工厂总结&lt;/h3&gt;

&lt;h4 id=&#34;优点-2&#34;&gt;优点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;类的数量精简了，当需要一个产品族来进行操作时，它可以保证客户端使用了同一产品族中的对象&lt;/li&gt;
&lt;li&gt;当需要新增加一种产品族时（换其它工厂来生产），无须修改系统，直接新建一个具体的工厂就可以实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;缺点-2&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;当需要增加新的产品类型时，需要修改最高的抽象工厂，这样具体的实现工厂也要进行修改，不符合开闭原则。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;啤酒工厂的类图：


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/factory.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/factory.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;工厂方法与抽象工厂对比&#34;&gt;工厂方法与抽象工厂对比&lt;/h2&gt;

&lt;p&gt;上面说的工厂方法与抽象工厂理解时有些困难，它们主要的不同点就是工厂方法适合生产产品结构相同的单种产品，而抽象工厂适合生产多种产品结构的产品，如白酒，这是另一个产品结构，这种情况使用抽象工厂更恰当。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之原型模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-yuan-xing-mo-shi/</link>
      <pubDate>Sat, 09 Jun 2018 17:12:41 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-yuan-xing-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;

&lt;p&gt;原型设计模式就是系统中产生的每一个对象都不相同，通过原型来创建新的对象，原型模式属于创建型模式。&lt;/p&gt;

&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;

&lt;p&gt;一般情况可以通过对象克隆的方式来根据一个对象创建出来多个对象，每个对象在内存占用的内存地址都不一样。在JAVA中克隆又分为浅克隆与深克隆。&lt;/p&gt;

&lt;h3 id=&#34;浅克隆&#34;&gt;浅克隆&lt;/h3&gt;

&lt;p&gt;JAVA中是按值进行传递。实现克隆的方式就是实现Cloneable接口，这样就可以重写Object对象的clone方法来进行对象的克隆。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Created by tomyli on 2018/5/30.
 * Github: https://github.com/peng051410
 */
public class Apple implements Cloneable {

    public String name;
    public double weight;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Apple apple = new Apple();
    apple.name = &amp;quot;apple&amp;quot;;
    apple.weight = 2.23;

    try {
        Apple clone = (Apple)apple.clone();
        System.out.println(clone == apple);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码中clone与apple是两个完全不同的对象，这样就通过apple这个原型创建出来一个全新的对象。但是这里存在一个问题，现在Apple对象中只包含了值类型的成员变量，如果包含了其它对象会克隆也会成功吗？我们在Apple对象中增加一个Stone对象的集合，代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Apple implements Cloneable {

    public String name;
    public double weight;
    public List&amp;lt;Stone&amp;gt; list; //新增加的对象

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次再使用测试代码进行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Apple clone = (Apple)apple.clone();
    System.out.println(clone == apple);
    System.out.println(clone.list == apple.list);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apple与clone依旧不相等，但是clone.list却与apple.list是相同的，这就没有达到我们的目的。在JAVA中对对象的拷贝其实拷贝的是内存地址，所以拷贝后两个list都指定了同一个内存地址。显然，浅克隆对只包含值类型的变量拷贝是正确的，而对包含对象的拷贝的处理是不符合预期的。&lt;/p&gt;

&lt;h3 id=&#34;深拷贝&#34;&gt;深拷贝&lt;/h3&gt;

&lt;p&gt;深拷贝就是通过对JAVA对象的序列化来进行对象的完整拷贝，主要是通过ObjectInputStream与ObjectOutputStream两个流来实现对象的读取与写入。示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Car implements Serializable {

public String name;
public String tag;
public Date birthday;

public Tire tire;

public Car deepCopy() throws Exception {

ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject(this);

ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
ObjectInputStream ois = new ObjectInputStream(bais);
Car copy = (Car) ois.readObject();
copy.birthday = new Date();
return copy;

}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中要确保每一辆车的出厂日期是唯一的，就要使用深拷贝来实现。要被克隆的对象需要实现Serializable接口。
深拷贝原型模式的类图如下:


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/prototype.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/prototype.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;

&lt;p&gt;系统中需要保存每个用户的信息，就要每个用户对应不同的实体对象。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;p&gt;原型设计模式可以进行快速的对象复制，可以很快的创建大的复杂的对象。&lt;/p&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;p&gt;创建对象的过程比较复杂，需要被克隆的对象要额外实现序列化接口。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式学习之单例模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dan-li-mo-shi/</link>
      <pubDate>Tue, 05 Jun 2018 16:36:08 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dan-li-mo-shi/</guid>
      
        <description>

&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;

&lt;p&gt;单例模式就是确保在系统中只在一个实例提供功能。单例有好几种写法，主要有饿汉式、懒汉式、静态方法内部类、注册式单例。&lt;/p&gt;

&lt;h2 id=&#34;饿汉式&#34;&gt;饿汉式&lt;/h2&gt;

&lt;p&gt;饿汉式单例就是在类定义时就已经将实例进行了初始化，在系统调用时可以直接返回不需要再实例化。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Hungry {

    private Hungry() {
    }

    private static final Hungry INSTANCE = new Hungry();

    public static Hungry getInstance() {
        return INSTANCE;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;饿汉式的优点是提前进行初始化，线程安全。缺点是在系统未调用的情况下占用了内存空间，是以空间换取时间的样例&lt;/p&gt;

&lt;h2 id=&#34;懒汉式&#34;&gt;懒汉式&lt;/h2&gt;

&lt;p&gt;懒汉式就是在使用才对对象实例进行初始化，达到了延迟加载的目的。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LazyOne {

    private LazyOne() {
    }

    private static LazyOne instance = null;

    public static LazyOne getInstance() {
        if (instance == null) {
            instance = new LazyOne();
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;懒式式优化点使用时实例化，延迟加载。缺点是存在线程安全问题&lt;/p&gt;

&lt;h2 id=&#34;懒汉式-线程安全版本&#34;&gt;懒汉式（线程安全版本）&lt;/h2&gt;

&lt;p&gt;上面的写法存在线程安全问题，最简单的修改方法是加上synchronized关键字，这样就解决了线程的安全问题。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LazyTwo {

    private LazyTwo() {
    }

    private static LazyTwo instance = null;

    public static synchronized LazyTwo getInstance() {
        if (instance == null) {
            instance = new LazyTwo();
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加了synchronized关键字解决了线程安全问题，但是程序的并发性能下降，因为在同一时间只能有一个线程进行工作。测试生成200万个实例的情况，不带关键字synchronized耗时7ms，而带synchroized的耗时49ms，相差7倍，加大生成实例的个数，这个时间差会更大，这个版本性能的测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;long start = System.currentTimeMillis();
int count = 2_000_000;
for (int i = 0; i &amp;lt; count; i++) {
    LazyOne.getInstance();
}
System.out.println(&amp;quot;LazyOne use: &amp;quot; + (System.currentTimeMillis() - start) + &amp;quot;ms&amp;quot;);


long start2 = System.currentTimeMillis();
for (int i = 0; i &amp;lt; count; i++) {
     LazyTwo.getInstance();
}
System.out.println(&amp;quot;LazyTwo use: &amp;quot; + (System.currentTimeMillis() - start2) + &amp;quot;ms&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;注册式单例&#34;&gt;注册式单例&lt;/h2&gt;

&lt;p&gt;注册式单例是Spring中使用的一种产生单例的方式，主要的思想就是将要产生的单例对象使用一样map进行存储。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final static Map&amp;lt;String, Object&amp;gt; singletonMaps = new ConcurrentHashMap&amp;lt;&amp;gt;();

public static Object getBean(String beanName) {

        if (null == beanName || &amp;quot;&amp;quot;.equals(beanName)) {
                throw new RuntimeException(&amp;quot;invalid beanName&amp;quot;);
        }

        if (!singletonMaps.containsKey(beanName)) {

                try {
                        synchronized (singletonMaps) {
                                Object o = Class.forName(beanName).newInstance();
                                singletonMaps.put(beanName, o);
                                return o;
                        }
                } catch (Exception e) {
                        e.printStackTrace();
                }
        }
        return singletonMaps.get(beanName);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring实际的生成单例bean的处理方式比这复杂很多。&lt;/p&gt;

&lt;h2 id=&#34;静态内部类方式&#34;&gt;静态内部类方式&lt;/h2&gt;

&lt;p&gt;静态内部类就是在一个类的内部又声明了一个类，静态内部类生成单例的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LazyThree  {

    private LazyThree() {
    }

    public static LazyThree getInstance() {
        return InstanceHolder.LAZY;
    }

    private static class InstanceHolder {
        private static final LazyThree LAZY = new LazyThree();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在类LazyThree的内部又声明了一个名为InstanceHolder的静态内部类，刚开始外部类初始化时内部类不会进行初始化，这样保留了懒加载的特性，只有在调用getInstance方法时内部类才初始化，JVM虚拟机内部的逻辑保证了在多线程情况静态内部类只给被初始化一次，这样也保证了线程的安全。但是JAVA提供我们程序员太多的方式来进行类的实例化，比如clone，反射，序列化。在这些情况下，我们的单例还是唯一的吗？&lt;/p&gt;

&lt;h2 id=&#34;打破单例之clone方式&#34;&gt;打破单例之Clone方式&lt;/h2&gt;

&lt;p&gt;在JAVA中所有对象都继承Object对象，实例对象实现Cloneable接口则可以进行clone，示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Object clone() throws CloneNotSupportedException {
        return super.clone();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LazyThree lazyThree = LazyThree.getInstance();
LazyThree clone = (LazyThree) lazyThree.clone();

System.out.println(lazyThree == clone);  //结果为false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解决clone方式下产生单例不一致的问题&#34;&gt;解决clone方式下产生单例不一致的问题&lt;/h3&gt;

&lt;p&gt;实例了cloneable接口的单例对象生成的实例不相同，此时我们要做的就是重写clone方法，让其使用我们静态内部类生成的单例，示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Object clone() throws CloneNotSupportedException {
        return getInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们重写了clone方式，生成的单例就是一样的了&lt;/p&gt;

&lt;h2 id=&#34;打破单例之反射方式&#34;&gt;打破单例之反射方式&lt;/h2&gt;

&lt;p&gt;反射是JAVA的一个利器，利用反射可以实例化对象，调用方法，动态的创建对象，使用反射创建实例的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor&amp;lt;LazyThree&amp;gt; constructor = LazyThree.class.getDeclaredConstructor(null);
constructor.setAccessible(true);
LazyThree lazyThreeReflect = constructor.newInstance(null);

LazyThree lazyThree = LazyThree.getInstance();
System.out.println(lazyThree == lazyThreeReflect);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的实例不是相同的，虽然我们的类已经把构造方法声明为了private，但是反射依然可以访问的到。&lt;/p&gt;

&lt;h3 id=&#34;解决反射产生单例不一致的问题&#34;&gt;解决反射产生单例不一致的问题&lt;/h3&gt;

&lt;p&gt;为了防止这种事情的发生，我们需要在构造方法上对类初始化状态进行标识来阻止类的多次初始化。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static boolean initial = false;

private LazyThree() {

        synchronized (LazyThree.class) {
                if (!initial) {
                        initial = true;
                } else {
                        throw new RuntimeException(&amp;quot;单例被侵犯&amp;quot;);
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们定义的一个静态变量initial来标识类有没有进行了初始化，并且不对外提供对initial变量的get与set方法。这样如实例已经初始化了，再次调用则抛出异常表明类已经被初始化了，这样就防止了使用反射方式来进行类的实例化了。&lt;/p&gt;

&lt;h2 id=&#34;打破单例之序列化反序列化&#34;&gt;打破单例之序列化反序列化&lt;/h2&gt;

&lt;p&gt;JAVA中的对象是可以持久化到磁盘上的，使用的方式就是序列化与反序列化，主要是使用ObjectInputStream与ObjectOutPutStream来实现。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LazyThree lazyThree = LazyThree.getInstance();

File file = new File(LazyTest.class.getResource(&amp;quot;&amp;quot;).getPath() + &amp;quot;/serializable.txt&amp;quot;);
FileOutputStream fps = new FileOutputStream(file);
ObjectOutputStream oos = new ObjectOutputStream(fps);
oos.writeObject(lazyThree);
oos.flush();
oos.close();

FileInputStream fis = new FileInputStream(file);
ObjectInputStream ois = new ObjectInputStream(fis);
LazyThree lazyThreeSerializable = (LazyThree) ois.readObject();
fis.close();
ois.close();

System.out.println(lazyThree == lazyThreeSerializable);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的结果为false，证明两个对象不相同&lt;/p&gt;

&lt;h3 id=&#34;解决序列化反序列化产生单例不一致的问题&#34;&gt;解决序列化反序列化产生单例不一致的问题&lt;/h3&gt;

&lt;p&gt;解决的方法要的ObjectInputStream读入对象时来处理，我们需要在类中增加readResolve方法，在这个方法返回我们生成单例的方式。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readResolve() {
        return getInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在读取对象信息时使用我们返回的实体对象就保证了对象的一致性。
单例模式的类图如下:


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://blog.imcompany.cn/ox-hugo/singleton.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;http://blog.imcompany.cn/ox-hugo/singleton.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;写一个单例不容易。
以下是完整的单例方式代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.imcompany.lazy;

import java.io.Serializable;

/**
 * Created by tomyli on 2018/6/2.
 * Github: https://github.com/peng051410
 */
public class LazyThree implements Cloneable, Serializable {

    private static boolean initial = false;

    private LazyThree() {

        synchronized (LazyThree.class) {
            if (!initial) {
                initial = true;
            } else {
                throw new RuntimeException(&amp;quot;单例被侵犯&amp;quot;);
            }
        }
    }

    public static LazyThree getInstance() {
        return InstanceHolder.LAZY;
    }

    private static class InstanceHolder {

        private static final LazyThree LAZY = new LazyThree();
    }

    private Object readResolve() {
        return getInstance();
    }

    // public static boolean isInintial() {
    //     return inintial;
    // }
    //
    // public static void setInintial(boolean inintial) {
    //     LazyThree.inintial = inintial;
    // }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return getInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Idea中vim键的映射</title>
      <link>http://blog.imcompany.cn/post/chang-yong-de-ideacha-jian/</link>
      <pubDate>Mon, 14 May 2018 14:48:33 +0800</pubDate>
      
      <guid>http://blog.imcompany.cn/post/chang-yong-de-ideacha-jian/</guid>
      
        <description>&lt;p&gt;Idea中IdeaVim插件可以让我们在Idea中使用vi的按键来进行操作，但是原生的配置只带有一些基本的移动操作。需要在~/.ideavimrc文件中进行Idea的动作映射来发挥它们的最大力量。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kj&lt;/td&gt;
&lt;td&gt;&lt;Esc&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gt&lt;/td&gt;
&lt;td&gt;VimBack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gT&lt;/td&gt;
&lt;td&gt;VimForward&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gd&lt;/td&gt;
&lt;td&gt;GotoDeclaration&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gf&lt;/td&gt;
&lt;td&gt;GotoTypeDeclaration&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gh&lt;/td&gt;
&lt;td&gt;QuickJavaDoc&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gs&lt;/td&gt;
&lt;td&gt;GotoSymbol&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gi&lt;/td&gt;
&lt;td&gt;GotoImplementation&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gu&lt;/td&gt;
&lt;td&gt;FindUsages&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gj&lt;/td&gt;
&lt;td&gt;IntroduceVariable&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w d&lt;/td&gt;
&lt;td&gt;ActivateDatabaseToolWindow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader &amp;lsquo;&lt;/td&gt;
&lt;td&gt;ActivateTerminalToolWindow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w r&lt;/td&gt;
&lt;td&gt;ActivateRedisServersToolWindow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w m&lt;/td&gt;
&lt;td&gt;ActivateMavenProjectsToolWindow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w a&lt;/td&gt;
&lt;td&gt;HideActiveWindow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w w&lt;/td&gt;
&lt;td&gt;HideAllWindows&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w p&lt;/td&gt;
&lt;td&gt;ActivateProjectToolWindow&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w s&lt;/td&gt;
&lt;td&gt;ActivateStructureToolWindow&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w v&lt;/td&gt;
&lt;td&gt;ActivateVersionControlToolWindow&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w h&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;h  Go to left window&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w l&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;l  Go to right window&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w k&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;k  Go to window up&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w j&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;j  Go to window down&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w V&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;v  Split Window Vertically&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w -&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;s  Split Winodw Horizontally&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w c&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;c  Close current window&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader w o&lt;/td&gt;
&lt;td&gt;&lt;c-w&gt;o  Close all window except current&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader &lt;Space&gt;&lt;/td&gt;
&lt;td&gt;GotoAction&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader c c&lt;/td&gt;
&lt;td&gt;GotoClass&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader c r&lt;/td&gt;
&lt;td&gt;CopyReference&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader c p&lt;/td&gt;
&lt;td&gt;CopyPaths&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader f f&lt;/td&gt;
&lt;td&gt;GotoFile&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader f d&lt;/td&gt;
&lt;td&gt;DashLauncherAction&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader b b&lt;/td&gt;
&lt;td&gt;RecentFiles&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader b p&lt;/td&gt;
&lt;td&gt;FileStructurePopup&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader b u&lt;/td&gt;
&lt;td&gt;ReopenClosedTab&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader d d&lt;/td&gt;
&lt;td&gt;Debug&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader d D&lt;/td&gt;
&lt;td&gt;DebugClass&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader d j&lt;/td&gt;
&lt;td&gt;JRebel&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader l l&lt;/td&gt;
&lt;td&gt;EvaluateExpression&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader t t&lt;/td&gt;
&lt;td&gt;ToggleLineBreakpoint&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader r r&lt;/td&gt;
&lt;td&gt;Run&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader r R&lt;/td&gt;
&lt;td&gt;RunClass&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader i m&lt;/td&gt;
&lt;td&gt;ImplementMethods&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader e e&lt;/td&gt;
&lt;td&gt;ShowErrorDescription&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader e n&lt;/td&gt;
&lt;td&gt;GotoNextError&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader R&lt;/td&gt;
&lt;td&gt;:source ~/.ideavimrc&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader g s&lt;/td&gt;
&lt;td&gt;Vcs.QuickListPopupAction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader r p&lt;/td&gt;
&lt;td&gt;ReplaceInPath&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;zO&lt;/td&gt;
&lt;td&gt;ExpandAllRegions&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;zo&lt;/td&gt;
&lt;td&gt;ExpandRegion&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;zc&lt;/td&gt;
&lt;td&gt;CollapseRegion&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;zC&lt;/td&gt;
&lt;td&gt;CollapseAllRegions&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fj&lt;/td&gt;
&lt;td&gt;emacsIDEAs.AceJump&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fw&lt;/td&gt;
&lt;td&gt;emacsIDEAs.AceJumpWord&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ff&lt;/td&gt;
&lt;td&gt;CommentByLineComment&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fb&lt;/td&gt;
&lt;td&gt;CommentByBlockComment&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gd&lt;/td&gt;
&lt;td&gt;GotoDeclaration&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gf&lt;/td&gt;
&lt;td&gt;GotoTypeDeclaration&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gh&lt;/td&gt;
&lt;td&gt;QuickJavaDoc&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gs&lt;/td&gt;
&lt;td&gt;GotoSymbol&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gi&lt;/td&gt;
&lt;td&gt;GotoImplementation&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gu&lt;/td&gt;
&lt;td&gt;FindUsages&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gj&lt;/td&gt;
&lt;td&gt;IntroduceVariable&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;,,&lt;/td&gt;
&lt;td&gt;ReformatCode&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;,r&lt;/td&gt;
&lt;td&gt;RenameElement&lt;CR&gt;i&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;c-o&gt;&lt;/td&gt;
&lt;td&gt;Back&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;c-i&gt;&lt;/td&gt;
&lt;td&gt;Forward&lt;cr&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader R&lt;/td&gt;
&lt;td&gt;reload ~/.ideavimrc&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader a l&lt;/td&gt;
&lt;td&gt;:actionlist&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader g s&lt;/td&gt;
&lt;td&gt;Vcs.QuickListPopupAction&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader s p&lt;/td&gt;
&lt;td&gt;FindInPath&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;leader r p&lt;/td&gt;
&lt;td&gt;ReplaceInPath&lt;CR&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;, c r&lt;/td&gt;
&lt;td&gt;Revert change&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;, c t&lt;/td&gt;
&lt;td&gt;Close other tab&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
  </channel>
</rss>
