<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on I&#39;m company</title>
    <link>http://blog.imcompany.cn/post/</link>
    <description>Recent content in Posts on I&#39;m company</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>peng051410@126.com (Tomyli)</managingEditor>
    <webMaster>peng051410@126.com (Tomyli)</webMaster>
    <lastBuildDate>Wed, 08 Jan 2020 18:54:09 +0800</lastBuildDate>
    
	<atom:link href="http://blog.imcompany.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2020-ARTS-打卡第一天</title>
      <link>http://blog.imcompany.cn/post/2020-arts-001/</link>
      <pubDate>Wed, 08 Jan 2020 18:54:09 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/2020-arts-001/</guid>
      <description>Algorithm 题目描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
Example 输入123-&amp;gt;321 输入-123-&amp;gt;-321 输入120-&amp;gt;21
题目解答 import java.util.*; public class Solution1 { public int[] reverseNumber(int num) { int res = 0; while(num != 0) { int pod = num % 10; if(res &amp;gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;amp;&amp;amp; pod &amp;gt; 7)) { return 0; } if(res &amp;lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;amp;&amp;amp; pod &amp;lt; -8)) { return 0; } res = res * 10 + pod; num = num / 10; } return res; } } 此题主要考察对栈的使用，如果不使用其它辅助类，则要考虑Int的整数溢出问题。时间复杂度O(log(n))，空间复杂度为O(1)</description>
    </item>
    
    <item>
      <title>Maven发布401问题排查</title>
      <link>http://blog.imcompany.cn/post/maven-deploy-issue/</link>
      <pubDate>Tue, 31 Dec 2019 11:15:55 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/maven-deploy-issue/</guid>
      <description>日志问题现象 Caused by: org.apache.maven.shared.transfer.artifact.deploy.ArtifactDeployerException: Failed to deploy artifacts: Could not transfer artifact com.aa.bb:client:jar:1.0.0-20191231.021137-1 from/to company::default (http://test.company.local/nexus/repository/maven-snapshots): Transfer failed for http://test.company.local/nexus/repository/maven-snapshots/com/aa/bb/client/1.0.0-SNAPSHOT/client-1.0.0-20191231.021137-1.jar 401 Unauthorized 根据提示，401未授权，表面来看就是发布的权限未认证
排查步骤 settings文件是否配置了发布的用户名与密码，且用户有deploy的权限 &amp;lt;servers&amp;gt; &amp;lt;server&amp;gt; &amp;lt;id&amp;gt;myid&amp;lt;/id&amp;gt; &amp;lt;username&amp;gt;myuser&amp;lt;/username&amp;gt; &amp;lt;password&amp;gt;mypasswd&amp;lt;/password&amp;gt; &amp;lt;/server&amp;gt; &amp;lt;/servers&amp;gt; 查看deploy插件的版本  如果是2.X的版本,可以使用以下命令进行发布  mvn -DaltDeploymentRepository=company::default::http://test.compnay.local/nexus/repository/maven-snapshots clean package deploy  如果是3.X的版本，则需要按3.X版本进行指定发布  mvn deploy:deploy-file -Dfile=xxx-1.0.0-SNAPSHOT.jar -Durl=http://test.local/nexus/content/repositories/snapshots -DrepositoryId=test-snapshot Deploy 3.0.0-M1的发布bug 如果配置的deploy的插件为3.0.0-M1，则可参考3.0.0-M1 401 bug 进行修改，具体就是指定depoly版本为2.8，根据插件作者的回复感觉就是3.0.0-M1与altDeploymentRepository参数不能一起用</description>
    </item>
    
    <item>
      <title>那些有用maven命令</title>
      <link>http://blog.imcompany.cn/post/maven-swim/</link>
      <pubDate>Tue, 31 Dec 2019 10:45:55 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/maven-swim/</guid>
      <description>查看当前系统的配置信息 排查问题可以查看当前maven所依赖系统的所有变量(系统变量或者环境变量)信息
mvn help:system 查看当前有效的settings文件 maven的配置文件分为全局配置与个人配置，全局配置在$M2_HOME/conf/下，个人配置一般在~/.m2/下，此时查看当前有效的settings配置可以使用
mvn help:effective-settings 查看Settings配置的值 以下命令可以查看settings文件中的settings-&amp;gt;servers的配置
mvn -q -Dexpression=settings.servers -DforceStdout help:evaluate 使用help:evaluate可以查看所有的配置信息
指定发布到其它仓库 Deploy插件2.X版本发布 有时候在pom文件中指定了发布的仓库地址，但是又需要发布到另一个仓库，这时可以指定-DaltDeploymentRepository来实现
mvn -DaltDeploymentRepository=id::layout::url 具体说明参见deploy:deploy
Deploy插件3.0.0-M1版本发布 /data/mvn/bin/mvn org.apache.maven.plugins:maven-deploy-plugin:3.0.0-M1:deploy-file -DgroupId=com.qqreader -Dfile=./target/$(/data/mvn/bin/mvn -q -Dexpression=project.build.finalName -DforceStdout help:evaluate).jar -Durl=http://testurl.local/nexus/content/repositories/snapshots -DrepositoryId=snapshot-id </description>
    </item>
    
    <item>
      <title>JAVA8问题处理回顾-持续更新</title>
      <link>http://blog.imcompany.cn/post/java8-issue-review/</link>
      <pubDate>Sat, 24 Aug 2019 10:15:55 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/java8-issue-review/</guid>
      <description>金额累加问题 使用Reduce进行累加操作，参考这里
List&amp;lt;BigDecimal&amp;gt; bdList = new ArrayList&amp;lt;&amp;gt;(); //populate list BigDecimal result = bdList.stream().reduce(BigDecimal.ZERO, BigDecimal::add); 查找集合的最后一个元素 JAVA8的Stream只提供了FindFirst功能，没有FindLast功能，可以使用Reduce来实现查找最后一个元素的效果
import java.util.*; import java.util.stream.*; public class GetLastEleFromCollection { public static void main(String[] args) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); list.add(&amp;#34;aaa&amp;#34;); list.add(&amp;#34;idddd&amp;#34;); list.add(&amp;#34;bbbb&amp;#34;); String lastElement = list.stream() .reduce((first, second) -&amp;gt; second) .orElse(null); System.out.println(lastElement); } } bbbb 比较两个时间是否是同一天 import java.time.*; import java.time.temporal.*; public class CompareDay { public static void main(String[] args) { final LocalDateTime now = LocalDateTime.</description>
    </item>
    
    <item>
      <title>Apollo Client自定义问题拾遗</title>
      <link>http://blog.imcompany.cn/post/apollo-client-custom/</link>
      <pubDate>Mon, 01 Jul 2019 07:04:09 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/apollo-client-custom/</guid>
      <description>由于公司很多服务要接入Apollo配置中心，并且对于项目的接入有网络要求，根据官方说明，需要自定义Client来完成
接入步骤 新建maven项目 在Idea中新建maven项目，基于quickstart构建
增加项目依赖 官方说明的建议在新的client中依赖Apollo官方的client，再根据业务进行扩展，所以maven依赖apollo-client，公司项目的网络访问需要通过L5来进行，所以还要依赖L5的jar，目前这个jar包没有maven坐标，只能以lib方式引入
自定义MetaServer 关键的部分，自定义满足公司网络条件的MetaServer，Apollo官网说明是实现MetaServerProvider且Order值小的Providor被使用，按照说明进行实现
Maven打包Client 执行 mvn clean install 进行打包，解压jar包发现就只有一个Providor的实现类，这样jar运行有问题。需要把新Client所有的依赖都打进jar包，在网上找了半天，需要在POM中增加maven的plugin的配置，如下：
&amp;lt;!-- 打包所有的maven依赖到jar包 --&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.1&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;artifactSet&amp;gt; &amp;lt;excludes&amp;gt; &amp;lt;exclude&amp;gt;junit:junit&amp;lt;/exclude&amp;gt; &amp;lt;/excludes&amp;gt; &amp;lt;/artifactSet&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;!-- 添加依赖的非maven jar包 --&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;com.googlecode.addjars-maven-plugin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;addjars-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.5&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;add-jars&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;${basedir}/lib&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; 由于项目中使用了maven依赖与非maven依赖，所以上述的两个插件都要使用。增加了上面两个插件后再运行打包命令查看生成的jar就发现所有的依赖都在jar中了。
项目中使用Client 选择一个项目在测试环境进行配置调试，自定义的Meta Server一直没有生效，所以查找官方文档，由于自定义Providor是通过SPI方式实现的，所以正确的实现方式是新建resource文件夹，指定MetaServerProvider的真正实现类的带包名类才可以，哎，找了我好久。
后续操作 后续会把client上传到内部maven仓库，完善配置API，使业务方可以零配置来使用配置中心。
总结  Maven的打包机制还是不清晰，处理打包问题费了很多时间，要好好重新学习一下 Apollo的官方文档还需要再仔细阅读，有问题多查issue，因为可能有人已经遇到了 多读读源码，真正的体会大牛的软件设计思想  </description>
    </item>
    
    <item>
      <title>Apollo 配置中心畅游</title>
      <link>http://blog.imcompany.cn/post/apollo-config-swim/</link>
      <pubDate>Thu, 09 May 2019 17:34:09 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/apollo-config-swim/</guid>
      <description>目前市面上的开源产品 Disconf 2014年7月百度开源的配置管理中心，同样具备配置的管理能力，目前已经不维护了，最近的一次代码提交是两年前了。
Spring Cloud Config 2014年9月开源，Spring Cloud生态组件，与Spring Cloud体系无缝整合。
Apollo 2016年5月，携程框架部开源的配置管理中心，具备规范的权限、流程治理等特性。
Nacos 2018年6月，阿里开源的配置中心，可以做DNS和RPC的服务发现。
为什么选择Apollo 社区活跃 刚刚发布了1.4.0版本，Issue处理速度快
文档齐全 体验，部署，设计文档都齐全
重要的灰度发布 想发布一台机器试试水，可以！
开源协议友好 Apache 2 license
Apollo都有哪些重要功能 以下摘自官网说明
统一管理不同环境、不同集群的配置 配置修改实时生效（热发布） 版本发布管理 目前只支持对最近版本的恢复。https://github.com/ctripcorp/apollo/issues/1642
灰度发布 权限管理、发布审核、操作审计 编辑与发布是两个独立的操作。
客户端配置信息监控 提供Java和.Net原生客户端 提供开放平台API 这样可以通过其它方式来查看配置信息，平台API说明
使用方便的后台配置系统Portal 分布式部署相对较复杂，这是缺点 外部依赖少，目前依赖Mysql
Apollo的组成 Apollo长什么样?     Apollo整体设计 总体架构     代码结构     各模块概要介绍
Apollo Config Service 提供配置获取接口，服务对象为Apollo客户端
Apollo Admin Service 提供配置管理（修改、发布）接口，服务与Portal
Apollo Portal 提供WEB界面供用户管理配置
Apollo的重要设计 Admin Service与Config Service的通信方式 Apollo使用Mysql实现消息(ReleaseMessage)的处理，消息内容为AppId+Cluster+Namespace，具体的设计思想可以参考这里</description>
    </item>
    
    <item>
      <title>ARTS-打卡第一天</title>
      <link>http://blog.imcompany.cn/post/arts-001/</link>
      <pubDate>Thu, 09 May 2019 17:34:09 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/arts-001/</guid>
      <description>Algorithm LeetCode 第一题
题目描述 给一个int数组，返回数组中两个数字相加的和是目标 数的下标。可以假设每个输入只有一个解决方案，并且不能使用同一个元素两次。
Example 给出nums = [2, 7, 11, 15], 目标数为9，则返回[0, 1]
题目解答 import java.util.*; public class Solution { public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; nums.length; i ++) { int second = target - nums[i]; if(map.containsKey(second)) { return new int[]{map.get(second), i}; } map.put(nums[i], i); } return new int[]{}; } } 相比两次循环的方式，这种处理的时间复杂度为O(n), 空间复杂度也为O(n).
Review Google Cloud Production Guideline，本文主要是针对Google的Colud平台事故进行了线上发布的总结指导（检查列表）。详细如下：</description>
    </item>
    
    <item>
      <title>Centos7 install issue collect</title>
      <link>http://blog.imcompany.cn/post/centos7-install-issue-collect/</link>
      <pubDate>Mon, 06 May 2019 13:00:55 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/centos7-install-issue-collect/</guid>
      <description>由于工作需要，使用VMWare虚拟机安装了Centos7系统，遇到了很多问题，现在把这些问题记录下来，以备后用。
解决Centos7 yum could not retrieve mirrorlist错误 刚安装好的VM使用ip add查看局域网的ip没有结果，这个参考https://my.oschina.net/u/2456768/blog/3011881
配置静态ip 安装虚拟机就是模拟多个机器通讯的情况，但是目前的配置是机器ip是动态获取的，老是变，每次都得看ip，所以需要配置一下VMware来支持静态ip。主要机器上的配置信息为：
IPADDR=192.168.116.101 NETMASK=255.255.255.0 GATEWAY=192.168.116.2 DNS1=192.168.116.2 这个参考了https://blog.csdn.net/zhishengqianjun/article/details/77046796
Centos7安装后配置国内仓库源 由于国内访问centos的原始源慢，需要换成163的软件源，新安装的系统执行命令都提示not found，只能从物理下载源的配置再上传到VM中，但是首先得知道VM的ip地址，使用ifconfig是不可能了，查了一下可以使用
ip a 来查看VM的ip地址，这样配置源的的问题可以解决了，具体的配置源的方法参考https://blog.csdn.net/inslow/article/details/54177191
Centos7安装VMware Tools 想更好的让VM与物理机协同，则VMware Tools必须要安装，好久不用linux的我连挂载也忘的一干二净了。搜了一下，参考https://blog.csdn.net/WarnerWu/article/details/73718901 完成VMware Tools的安装。这样共享目录的功能就可以正常使用了
安装Jdk8 一句命令搞定：
yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel 安装mysql 使用yum安装mysql需要下载安装mysql的源，更新后就可以安装了，这个参考了https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7/
修改mysql的root密码 安装完mysql后登录找不到密码了，其实在使用yum安装时会mysql会自动生成一个随机密码，这个密码可以在安装的日志中找到。此方法参考了https://blog.csdn.net/kuluzs/article/details/51924086
开放3306端口 为了方便mysql工具进行操作，需要开放3306端口。Centos7的防火墙还改了。具体就3个命令：
systemctl start firewalld firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload 这个参考了https://www.jianshu.com/p/225a853350d9
安装oh-my-bash 由于一般服务器都自带bash为默认的shell，但是操作起来着实不方便，安装oh-my-bash可以对shell进行一些增强。https://github.com/ohmybash/oh-my-bash
Centos自动登录 安装后每次启动VM都要输入密码，这个对于自己测试很麻烦，要使Centos能登录后自动登录需要做以下操作：
  移除原来的getty@tty1.service软链接
rm /etc/systemd/system/getty.target.wants/getty@tty1.service   拷贝getty@.service file 并且命名为 getty@tty1.service
cp /lib/systemd/system/getty@.service /etc/systemd/system/getty@tty1.service   编辑新拷贝的getty@tty1.</description>
    </item>
    
    <item>
      <title>那些高效的Chrome插件</title>
      <link>http://blog.imcompany.cn/post/na-xie-gao-xiao-de-chromecha-jian/</link>
      <pubDate>Fri, 08 Mar 2019 07:48:34 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/na-xie-gao-xiao-de-chromecha-jian/</guid>
      <description>1Password extension 密码管理工具1Password的Chrome插件。插件地址
Auto Refresh 自动刷新网页的插件，支持设置刷新时间间隔。插件地址
Awesome Autocomplete for GitHub 在浏览器中为Github增强搜索功能。插件地址
BetterTweetDeck TweetDeck功能增强，如支持表情，只看某人的tweets，插件地址
Chrono下载管理器 功能全面的chrome下载管理器，满足你的一切需求。插件地址
Clutter Free - Prevent duplicate tabs 防止打开相同的tab页面。插件地址
Dualsub 让Youtube同时显示两种语言的字幕。插件地址
GitHub Hovercard 鼠标Hover时更全面显示Github上个人与仓库的信息。插件地址
Insight.io for Github 为Github添加类似IDE的功能，高效的代码浏览工具。插件地址
JSON-handle JSON数据处理插件。插件地址
JSON Viewer Awesome JSON数据美化，漂亮的不行不行的。插件地址
Org Capture Org Capture的Chrome插件，支持Capture网页链接与选中文字，配合Emacs使用。插件地址
MAMA-HD 解决在看视频网站时Mac发热的问题。插件地址
Proxy SwitchyOmega 网页代理切换，支持定义多种模式。插件地址
Sourcegraph 在线浏览Github的源码，支持一些语言的语义跳转。插件地址
Surfingkeys 严重推荐，VIM键盘模拟，自定义程度非常高。插件地址
Tampermonkey 用户自定义脚本管理器。插件地址
YAAW for Chrome 使用YAAW处理Chrome的下载请求。插件地址
二管家 Chrome扩展管理器，快速开启、禁用，模式快速切换，更强大的是可以自定义插件的启用规则，这个很赞。插件地址
二箱 多个网站的以图搜图插件，能用图说的咱决不打字。插件地址
沙拉查词-聚合词典划词翻译 更人性化的划词扩展。插件地址
简悦 - SimpRead 沉浸式阅读首选，支持大多数的网站。插件地址
Clearly 更好的英文网页浏览选择，带文字朗读功能。插件地址
Read Aloud 朗读英文文章的更好选择，它只会朗读标题与正文。可以选择朗读语间，音调，速度。插件地址</description>
    </item>
    
    <item>
      <title>那些提高效率的命令行工具</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ming-ling-xing-gong-ju/</link>
      <pubDate>Sun, 30 Sep 2018 07:15:55 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ming-ling-xing-gong-ju/</guid>
      <description>Brew Mac软件包管理工具。用命令行命令来安装软件，仓库软件丰富。地址
bat bat? No，高端cat，不费眼。带颜色显示，支持git状态，自动分页。地址
cowsay 奶牛说： 地址
coreutils 使用Rust重写的gnuutils。地址
direnv 环境变量切换，可以指定在进入某一文件夹后的操作，比如输出一条欢迎语句，在退出文件夹后则卸载变量（操作），它的[stdlib](https://github.com/direnv/direnv/blob/master/stdlib.sh
)内置了一些功能来处理环境。 地址
exa ls、tree的替代者，支持多种显示方式，支持按指定条件排序显示。地址
duti mac默认软件打开程序配置。再也不用一个手动的点击设置了，可以脚本化。地址
riggrep 强大的find，查询速度更快，支持匹配结果的字符替换，支持定义输出颜色。地址
fortune 英文名言集合，可以使用fortunes进行扩展，对中文用户更友好。地址
fzf 强大的交互式搜索，大大提高效率，官网提供了很多实用的操作目录与git的命令。地址
goku 改键神器Karabiner的配置管理器，更健康，更人性化。地址
htop 交互式的top信息显示，支持配色。地址
imgcat 命令行看图片。可以控制显示的高度、宽度。地址
jq json内容操作显示。支持分离、过滤、转换元素，判断JSON元素节点是否存在等功能，内置了很多方便的函数。 地址
jenv JDK版本管理命令行工具，支持全局、当前目录、当前shell的jdk版本指定。还可以指定Java虚拟机指定的JVM参数。支持插件的启用与禁用。地址
lnav log file navigator，增加的日志查看，可以根据日志级别显示不同颜色的日志信息。支持分页显示。地址
lolcat 命令、文件内容多彩输出。地址
m-cli Mac的瑞士军刀，支持各种mac组件(Dock，蓝牙，WIFI，Finder)的操作。地址
mackup Mac应用配置同步，支持多种存储方式。支持自定义应用的同步配置。主要命令为backup，restore，uninstall。地址
mas 命令行安装apple store应用。地址
mycli 命令行中的mysql客户端。地址
ncdu 增强版本的du，机器空间使用查询，支持扫描结果导出与导入，支持多种排序方式。地址
Ranger 命令行下的文件管理，强大到没朋友。地址
pandoc 文档转换，支持非常多的的格式转换。地址
pyenv pythne版本管理工具。地址
pyenv-virtualenv pythne虚拟环境管理，管理pyenv配置的环境。地址
prettyping 增强的ping，图形化显示，可以轻松的看出ping的地址的网络状况。地址
rtv 命令行中浏览reddit。地址
s-search 命令行下进行web搜索。地址
tmux 终端多会话管理器。地址
tldr 命令快速查询。简单的man。地址</description>
    </item>
    
    <item>
      <title>那些提高效率的Alfred Workflow</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-alfred-workflow/</link>
      <pubDate>Fri, 21 Sep 2018 10:02:49 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-alfred-workflow/</guid>
      <description>Alfred Browser Toolbox Toolbox是一个文件操作浏览的工具，它支持创建、查找文件的功能，还可以查询pdf文件，非常方便。Mac上的Finder使用确定不方便。这里有具体的使用方式。
Alfred Keywords Help 安装的workflow多了，记忆触发的keyword就比较困难，使用Keywords help这个插件可以显示出所有已经安装的workflow的触发key，还可以根据workflow进行查询。
Alfred Maestro 操作Maestro的workflow，可以直接查找macro并执行。插件地址
Alfred My Mind 快速查询Nikita的githubpage内容的workflow，我在他的文章里面学到了很多。插件地址
Awesome lists 快速查询Github上awesome列表的workflow，只为发现更多。插件地址，这个也是Nikita的作品。
Baidu Map 在alfred上使用百度地图。插件地址
Birthday 在alfred中显示你来到这个世界多长时间，让你珍惜每一分，每一秒。插件地址
Calendar 在alfred中显示出当月的日历信息。插件地址
Chromes Bookmarks 在aflred中搜索Chrome浏览器的书签，非常的好用。插件地址
Common Search 国内常用网站的搜索，现在支持知乎、淘宝、掘金、github。插件地址
Dash 在alfred中进行Dash的搜索，开发者必备。插件地址
Directory watches 本地目录文件查看，指定目录的搜索，回收站文件显示。
Emacs Workflow 在alfred中进行emacs的操作，比如打开文件等。插件地址
Eudic 插件说明 使用欧路词典进行快速翻译。插件地址
Git Repos 插件说明 搜索本地的git文件夹，搜索到后可以使用指定软件进行打开，开发时很有用。插件地址
插件说明 搜索github上的项目，可以搜索项目，人物等。插件地址
Google Chrome History 在alfred中快速查看Chrome的浏览历史。插件地址
Hammerspoon Workflow 在alfred中调用hammerspon脚本的workflow。插件地址
Homebrew &amp;amp; Cask for Alfred 在alfred中进行mac软件的更新、查看、安装等。插件地址
iTerm Sessions 在alfre中快速切换iterm中存在的session窗口。插件地址
Kill Process 在alfred中kill进程，有时候程序假死，使用这个很方便，不用再在苹果的菜单栏中点击好几下来操作了。插件地址
Last changed files 显示出当前系统最新修改的文件，对于系统有什么修改一目了然。</description>
    </item>
    
    <item>
      <title>那些提高效率的Idea插件</title>
      <link>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ideacha-jian/</link>
      <pubDate>Wed, 05 Sep 2018 08:12:23 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/na-xie-ti-gao-xiao-lu-de-ideacha-jian/</guid>
      <description>.ignore 插件说明 ignore文件忽略，支持绝大多数的开发语言，支持直接导航到忽略的文件，在创建时可以选择模板，比如Java开发可以选择Java与Idea选项来生成忽略target文件与.idea文件等的忽略规则。
项目地址 https://github.com/hsz/idea-gitignore
IdeaVim 插件说明 在Idea中使用vi键位来进行编码操作,可以很高的提高效率,插件支持自定义键位来对Idea的action来进行定制,程序员可以根据自己的编程习惯来定制出一个键盘流来.
项目地址 https://github.com/JetBrains/ideavim
emacsIDEAs 插件说明 支持一些Emacs操作的Idea插件,主要是一些复制,移动,替换,跳转的快捷操作,目前使用最多的是快速查找替换.
项目地址 https://github.com/whunmr/emacsIDEAs
Custom Postfix Templates 插件说明 Idea中非常高效的就是postfix，但是系统自带不可以进行增加，这个插件就可以让用户可以自定义一些高级的postfix语句来提高效率。
项目地址 https://github.com/xylo/intellij-postfix-templates
Jrebel 插件说明 动态部署代码插件,可以在不重启Tomcat的情况下进行代码的热部署，提高开发效率没得说。先前可以使用twitter号来免费使用，现在不行，需要自行购买了。
项目地址 https://zeroturnaround.com/software/jrebel/
CamelCase 插件说明 文本驼峰规则快速转换，支持从CamelCase-&amp;gt;camelCaase-&amp;gt;camel_case-&amp;gt;camel-case-&amp;gt;CAMEL_CASE的顺序转换，idea中只支持全部大写与全部小写的转换.
项目地址 https://plugins.jetbrains.com/plugin/7160-camelcase
Codehelper 插件说明  代码自动生成插件，支持根据Pojo名来生成dao,mapper,xml等文件，目前使用较少 生成实体类的setter方法，使用频率高，主要是生成类的setter方法，配合F2查找下一个错误而使焦点至上而下，操作起来非常顺畅。  项目地址 https://github.com/zhengjunbase/codehelper.generator
Translation 插件说明 Idea中集成翻译功能,目前支持有道和goolge,百度翻译.
项目地址 https://github.com/izhangzhihao/intellij-rainbow-brackets
Clock 插件说明 当你全屏投入工作时，想知道当前的时间，需要切换出全屏模式，这样就打乱了节奏，这个插件可以在Idea的右下方显示出当前的时间信息，非常实用。
插件地址 https://github.com/amolenaar/idea-clock
Dash 插件说明 Dash是一个mac上的开发文档查询工具,Idea Dash这个插件使得开发者可以直接通过快捷键来调用Dash工具进行文档的查询.目前这个插件提供了对Dash,Velocity,Zeald三种工具的支持.
项目地址 https://github.com/gdelmas/IntelliJDashPlugin
Rainbow Brackets 插件说明 让Idea的括号更好看，对于对应的括号(标签)会显示相同的颜色，特别对于编写html时的标签对应，一眼就可以看出来标签是不是对应出现的。
项目地址 https://github.com/izhangzhihao/intellij-rainbow-brackets
RestfulToolkit 插件说明 此项目可以快速查询Springmvc项目中Controller的Mapping定义，即根据url来跳转方法定义，在原有Idea的按类、按文件、按方法名查找功能上增添新的查找功能。非常好用。
项目地址 https://plugins.jetbrains.com/plugin/10292-restfultoolkit
Duplicate Lines 插件说明 这是一个快速复制行内容的插件,Idea默认也是支持复制行的操作,当你选中了括号中的文字时再想进行复制编辑时这个插件就可以发挥作用了,它会复制行的内容,并将光标置于被复制行时选中的字符上,这样就可以接着进行复制后的修改操作了.</description>
    </item>
    
    <item>
      <title>设计模式学习之代理模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dai-li-mo-shi/</link>
      <pubDate>Mon, 16 Jul 2018 21:08:28 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dai-li-mo-shi/</guid>
      <description>说明 代理模式是设计模式中使用频率非常的高的模式，像日常生活中的房产中介、外卖平台都属于代理。代理模式就是在访问真正的业务之时不会直接与真正的业务进行调用，而是与一个与真正业务对象有着相同功能声明的代理来进行处理，但是最终的处理还是由真正的业务类来进行（决定），比如房产中介，他们会帮助找房者根据条件来对可选房屋进行筛选，但是最终订与不订的权利还是由找房者来决定。常见的代理有保护代理、虚拟代理、远程代理。
代理模式 我们常用的后台系统一般会根据用户权限的不同对用户展示不同的业务菜单，拥有高权限的人会展示相对多的菜单进行操作，在这个过程中还要记录用户的操作日志，用户点了什么，执行了什么操作都需要进行记录，达到有据可查。在这个业务场景下，就可以使用代理模式进行实现。代理对象会持有一个真正业务对象的实例，在代理对象中还引用日志服务与权限服务，所有的请求都经过这个代理类来进行，这样就可以根据操作的用户的状态来进行相应的处理了。具体的代码实现如下：
 定义一个查询接口，在这里定义一个查询用户收入的方法，如下:  package cn.imcompany.proxy; /** * Created by tomyli on 2018/6/28. * Github: https://github.com/peng051410 */ public interface Search { void queryIncome(String username); }  再定义一个实现该接口的具体业务类：  package cn.imcompany.proxy; /** * Created by tomyli on 2018/6/28. * Github: https://github.com/peng051410 */ public class SearchService implements Search { @Override public void queryIncome(String username) { System.out.println(username + &amp;#34;开始查询&amp;#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(username + &amp;#34;查询完成&amp;#34;); } } 在上面代码中就实现了查询收入的方法，简单的打印了两行日志。</description>
    </item>
    
    <item>
      <title>设计模式学习之委托模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-wei-tuo-mo-shi/</link>
      <pubDate>Sat, 07 Jul 2018 18:53:57 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-wei-tuo-mo-shi/</guid>
      <description>说明 委托模式不属于23种设计模式中，但是它在Spring框架中使用的很频繁，Spring的作用在Java的开发是非常大，所以需要学习一下委托模式。委托模式是指两个对象都有相同的方法与功能，比如A、B两个对象都有相同的方法，但是有调用A的method方法，A不会自己来处理而是直接调用了B的同名方法，由两个对象参与同一个请求，接受请求的对象将委托给另一个对象来处理。
委托模式 在一般的公司中，都会分为老板、项目经理、开发人员结构，老板负责制定决策，分配给项目经理后，他不会自己来完成，而是把需要的功能进行分解，交给擅长的开发人员进行实现。虽然项目经理也可以完成，但是是他把这些事情委托给了多个开发人员来做，加快了完成任务的速度。就以这个需求来说，使用委托模式来进行实现:
定义抽象的人类接口：
package cn.imcompany.delegate; /** * Created by tomyli on 2018/6/27. * Github: https://github.com/peng051410 */ public interface Member { void showName(); void showSkill(); void doWork(); } 上面代码中定义了抽象的人类接口，显示这个人的名字，拥有的技能，工作的状态情况，接下来实现需求中的每个人。
定义老板(BOSS):
package cn.imcompany.delegate; /** * Created by tomyli on 2018/6/27. * Github: https://github.com/peng051410 */ public class Boss implements Member { @Override public void showName() { System.out.println(&amp;#34;i am boss&amp;#34;); } @Override public void showSkill() { System.out.println(&amp;#34;send commend&amp;#34;); } @Override public void doWork() { } } 定义项目经理和员工:</description>
    </item>
    
    <item>
      <title>设计模式学习之观察者</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-guan-cha-zhe/</link>
      <pubDate>Wed, 04 Jul 2018 20:31:41 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-guan-cha-zhe/</guid>
      <description>说明 观察者模式在日常开发中使用频率也是非常高的，它建立了对象与对象之间的关系，一个对象的行为改变会通知到另一个对象，被通知的对象根据通知做出相应的处理动作。在观察者中分为目标对象（被观察者）、观察者。观察者模式是一种对象行为模式。
观察者模式 现在很多人都购买股票，在市面上有很多的股票软件供广大股民使用。股票软件一般会在用户关注的股票有变动时发送消息来通知股民。在这里，某一支股票就是目标对象，广大股民与股票软件就是观察者，他们根据股票的行情变化来做出相应买入或者卖出操作。这一需求可以使用观察者模式进行实现。代码如下：
先来定义一个抽象的购买股票的股民们，他们有喜有悲的心情:
package cn.imcompany.observer.stock; /** * Created by tomyli on 2018/6/23. * Github: https://github.com/peng051410 */ public interface Buyer { void setName(String name); String getName(); void happy(); void sad(); } 再来定义具体的股民行为实现类：
package cn.imcompany.observer.stock; /** * Created by tomyli on 2018/6/23. * Github: https://github.com/peng051410 */ public class ConcrectBuyer implements Buyer { private String name; @Override public void setName(String name) { this.name = name; } @Override public String getName() { return name; } @Override public void happy() { System.</description>
    </item>
    
    <item>
      <title>设计模式学习之装饰器</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/</link>
      <pubDate>Mon, 02 Jul 2018 20:09:14 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/</guid>
      <description>说明 装饰器设计模式是使用比较频繁的设计模式，它在不改变原物体的情况对原物体实现了功能的增加，原物体还是一个可单独使用的个体。在JAVA的类库中应该会马上想到IO类，各种的InputStrem，OutputStrem。
装饰器模式 在用户登录的中过程，我们需要对用户输入的密码进行加密操作，在设计时会提供好多种加密的算法，例如简单的BASE64加密，复杂的如MD5、DSA加密。直接把用户的密码存入数据库是真的在耍流氓。在使用这些算法时，我们想灵活的使用，比如使用完简单加密还可以再进行一下MD5的加密。针对这样的需求，可以使用装饰器模式进行实现。大体思路如下：
 加密接口，定义加密方法。 在装饰器中，最原始的被装饰者是目标实现，它们一般会实现加密定义的具体方法。 装饰者会针对目标对象进行装饰，所以它要同样实现加密接口的方法，一般情况下这个装饰器会定义为抽象的形式，在这个装饰器父类中维护着对目标对象的引用。 具体装饰器继承抽象装饰器来实现对目标对象的真正装饰操作。  以上的情况在代码上体现为如下形式：
 加密接口  package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public interface Encryptor { void encrypt(); }  具体加密类，实现加密处理接口  package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public class ConcreteEncryptor implements Encryptor { @Override public void encrypt() { System.out.println(&amp;#34;base encrypt!&amp;#34;); } }  抽象加密装饰器  package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25.</description>
    </item>
    
    <item>
      <title>设计模式学习之适配器</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gua-pei-qi/</link>
      <pubDate>Tue, 26 Jun 2018 21:30:17 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gua-pei-qi/</guid>
      <description>说明 在前面的文章中介绍了一些关于支付相关的功能，现在转向登录，在早些时期的系统登录就是用户使用用户名与密码进行注册，注册成功后就可以进行登录了。随着时代的发展，出现很多三方的平台，它们对外提供了获取平台用户信息的功能，例如微信、qq、微博等三方登录，在接入这些三方登录时都是遵循相应的规则，老的登录的方式需要保留，对接新的登录方式还想要使用老的登录服务，这样可以使用适配器模式来实现。
适配器模式 比如我们平常使用的转接头一样，就是一种适配器的模式。它使两个不相关的物体很好的关联在一起。对于要接入的新的登录方式，首先定义新的三方登录的接口，定义要使用的三方登录方式，如下代码示例：
package cn.imcompany.adapter; /** * Created by tomyli on 2018/6/22. * Github: https://github.com/peng051410 */ public interface ThirdLogin { void wechatLogin(String accessToken); void qqLogin(String accessToken); void sinaLogin(String accessToken); } 如上定义了微信、qq、微博三种登录方式，它们都是使用accessToken来进行认证，经用户同意后获取相应的用户的信息调用方使用。下面来进行具体的实现：
package cn.imcompany.adapter; /** * Created by tomyli on 2018/6/22. * Github: https://github.com/peng051410 */ public class ThirdLoginAdapter implements ThirdLogin { private LoginService loginService; public ThirdLoginAdapter() { this.loginService = new LoginService(); } @Override public void wechatLogin(String accessToken) { System.out.println(&amp;#34;微信获取用户信息&amp;#34;); loginService.login(accessToken, null); } @Override public void qqLogin(String accessToken) { System.</description>
    </item>
    
    <item>
      <title>设计模式学习之模板模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi/</link>
      <pubDate>Mon, 25 Jun 2018 21:06:17 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi/</guid>
      <description>说明 在一般实现处理用户支付订单时，通常都会在一个单独的回调项目中来处理用户的支付方式回调。一般情况下，回调的处理过程都是相似的，大体的步骤就是获取参数-&amp;gt;验证参数-&amp;gt;验证签名-&amp;gt;验证支付状态（可选）-&amp;gt;订单状态为成功增加用户的充值金额。具体的过程由于不同的支付方式不同而处理的不同。这种需求可以使用模板的模板模式来实现。
模板设计模式实现 模板模式就是由一个类来声明整个处理流程的步骤，具体的实现由各个实现类来进行实现。处理的流程不变，变是就是里面具体的实现。针对上面的支付回调，可以声明一个抽象类来声明具体的流程方法，代码如下：
package cn.imcompany.callback; import java.util.Map; /** * Created by tomyli on 2018/6/21. * Github: https://github.com/peng051410 */ public abstract class PayCallback { public abstract Map&amp;lt;String, String&amp;gt; getParam(); public abstract boolean checkParam(Map&amp;lt;String, String&amp;gt; param); public abstract boolean validSign(); /** * 定义了一个钩子方法来让子类控制流程实现 * @return true：强制返回，false：不强制返回 */ public boolean forceReturn() { return false; } public String doService() { Map&amp;lt;String, String&amp;gt; map = getParam(); if (!checkParam(map)) { return &amp;#34;param fail&amp;#34;; } if (!</description>
    </item>
    
    <item>
      <title>设计模式学习之策略模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-ce-lue-mo-shi/</link>
      <pubDate>Wed, 20 Jun 2018 07:04:56 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-ce-lue-mo-shi/</guid>
      <description>说明 策略模式是设计模式中使用频率很高的模式，主要的就是实现对行为的包装，达到结果的方式有多种，使用者可以选择任何一个方式来得到想要结果，在增加新的方式时更加的方便与灵活。它是为了适应算法的灵活性而产生的。
策略模式实现 以常用的购物为例，一般情况下购物分为浏览商品，下单，支付。在支付时消费者可以选择多种不同的支付方式，如支付宝、微信、京东支付、银联支付等。在支付中流程就可以使用到策略模式，网站为用户提供了这些支付方式可供选择，用户只需要选择自己喜欢的支付方式来进行充值就可以得到商品了。在一般情况下都会定义一个抽象类来定义支付的一些行为，如金额，商品简介等信息。实现的抽象类如以下定义：
package cn.imcompany.pay; /** * Created by tomyli on 2018/6/20. * Github: https://github.com/peng051410 */ public interface Payment { boolean pay(String param); } 这样就定义了支付方式的行为，剩下的就由不同的支付方式来进行实现，比如支付宝支付、微信支付，示例代码如下：
package cn.imcompany.pay; /** * Created by tomyli on 2018/6/20. * Github: https://github.com/peng051410 */ public class AliPay implements Payment { @Override public boolean pay(String param) { System.out.println(&amp;#34;AliPay&amp;#34;); return true; } } public class WechatPay implements Payment { @Override public boolean pay(String param) { System.out.println(&amp;#34;WechatPay&amp;#34;); return true; } } 要是再增加一种支付方式则可以实现Payment接口进行实现就可以了，一般情况下会有一个维护支付方式的常量类，由它来维护可用的支付方式。这个常量类的简化代码如下：</description>
    </item>
    
    <item>
      <title>设计模式学习之工厂模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gong-han-mo-shi/</link>
      <pubDate>Tue, 12 Jun 2018 21:33:40 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gong-han-mo-shi/</guid>
      <description>说明 工厂设计模式是23种设计模式中使用频率非常高的，属于创建型模式。主要特点是实现了实体创建与使用的分离，达到了解耦的目的。工厂设计模式一般分为简单工厂、工厂方法、抽象工厂。
前提准备 4年一界世界杯即将到来，啤酒厂商又要大嫌一笔。我们先准备好要生产的啤酒实体。
package cn.imcompany; /** * Created by tomyli on 2018/5/27. * Github: https://github.com/peng051410 */ public interface Beer { String getName(); } public class JinShiBai implements Beer { @Override public String getName() { return &amp;#34;金士百&amp;#34;; } } public class QingDao implements Beer { @Override public String getName() { return &amp;#34;青岛&amp;#34;; } } public class BaiWei implements Beer { @Override public String getName() { return &amp;#34;百威&amp;#34;; } } 在上面定义三种啤酒，它们都由抽象类Beer继承而来。下面使用简单工厂来给消费者提供啤酒。</description>
    </item>
    
    <item>
      <title>设计模式学习之原型模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-yuan-xing-mo-shi/</link>
      <pubDate>Sat, 09 Jun 2018 17:12:41 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-yuan-xing-mo-shi/</guid>
      <description>特点 原型设计模式就是系统中产生的每一个对象都不相同，通过原型来创建新的对象，原型模式属于创建型模式。
实现方式 一般情况可以通过对象克隆的方式来根据一个对象创建出来多个对象，每个对象在内存占用的内存地址都不一样。在JAVA中克隆又分为浅克隆与深克隆。
浅克隆 JAVA中是按值进行传递。实现克隆的方式就是实现Cloneable接口，这样就可以重写Object对象的clone方法来进行对象的克隆。代码如下：
/** * Created by tomyli on 2018/5/30. * Github: https://github.com/peng051410 */ public class Apple implements Cloneable { public String name; public double weight; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } 测试代码如下：
public static void main(String[] args) throws Exception { Apple apple = new Apple(); apple.name = &amp;#34;apple&amp;#34;; apple.weight = 2.23; try { Apple clone = (Apple)apple.clone(); System.out.println(clone == apple); } catch (Exception e) { e.</description>
    </item>
    
    <item>
      <title>设计模式学习之单例模式</title>
      <link>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dan-li-mo-shi/</link>
      <pubDate>Tue, 05 Jun 2018 16:36:08 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dan-li-mo-shi/</guid>
      <description>特点 单例模式就是确保在系统中只在一个实例提供功能。单例有好几种写法，主要有饿汉式、懒汉式、静态方法内部类、注册式单例。
饿汉式 饿汉式单例就是在类定义时就已经将实例进行了初始化，在系统调用时可以直接返回不需要再实例化。示例代码如下：
public class Hungry { private Hungry() { } private static final Hungry INSTANCE = new Hungry(); public static Hungry getInstance() { return INSTANCE; } } 饿汉式的优点是提前进行初始化，线程安全。缺点是在系统未调用的情况下占用了内存空间，是以空间换取时间的样例
懒汉式 懒汉式就是在使用才对对象实例进行初始化，达到了延迟加载的目的。示例代码如下：
public class LazyOne { private LazyOne() { } private static LazyOne instance = null; public static LazyOne getInstance() { if (instance == null) { instance = new LazyOne(); } return instance; } } 懒式式优化点使用时实例化，延迟加载。缺点是存在线程安全问题
懒汉式（线程安全版本） 上面的写法存在线程安全问题，最简单的修改方法是加上synchronized关键字，这样就解决了线程的安全问题。示例代码如下：
public class LazyTwo { private LazyTwo() { } private static LazyTwo instance = null; public static synchronized LazyTwo getInstance() { if (instance == null) { instance = new LazyTwo(); } return instance; } } 加了synchronized关键字解决了线程安全问题，但是程序的并发性能下降，因为在同一时间只能有一个线程进行工作。测试生成200万个实例的情况，不带关键字synchronized耗时7ms，而带synchroized的耗时49ms，相差7倍，加大生成实例的个数，这个时间差会更大，这个版本性能的测试代码如下：</description>
    </item>
    
    <item>
      <title>Idea中vim键的映射</title>
      <link>http://blog.imcompany.cn/post/chang-yong-de-ideacha-jian/</link>
      <pubDate>Mon, 14 May 2018 14:48:33 +0800</pubDate>
      <author>peng051410@126.com (Tomyli)</author>
      <guid>http://blog.imcompany.cn/post/chang-yong-de-ideacha-jian/</guid>
      <description>Idea中IdeaVim插件可以让我们在Idea中使用vi的按键来进行操作，但是原生的配置只带有一些基本的移动操作。需要在~/.ideavimrc文件中进行Idea的动作映射来发挥它们的最大力量。
   Key Description     kj    gt VimBack   gT VimForward   gd GotoDeclaration   gf GotoTypeDeclaration   gh QuickJavaDoc   gs GotoSymbol   gi GotoImplementation   gu FindUsages   gj IntroduceVariable   leader w d ActivateDatabaseToolWindow   leader &#39; ActivateTerminalToolWindow   leader w r ActivateRedisServersToolWindow   leader w m ActivateMavenProjectsToolWindow   leader w a HideActiveWindow   leader w w HideAllWindows   leader w p ActivateProjectToolWindow   leader w s ActivateStructureToolWindow   leader w v ActivateVersionControlToolWindow   leader w h h Go to left window   leader w l l Go to right window   leader w k k Go to window up   leader w j j Go to window down   leader w V v Split Window Vertically   leader w - s Split Winodw Horizontally   leader w c c Close current window   leader w o o Close all window except current   leader  GotoAction   leader c c GotoClass   leader c r CopyReference   leader c p CopyPaths   leader f f GotoFile   leader f d DashLauncherAction   leader b b RecentFiles   leader b p FileStructurePopup   leader b u ReopenClosedTab   leader d d Debug   leader d D DebugClass   leader d j JRebel   leader l l EvaluateExpression   leader t t ToggleLineBreakpoint   leader r r Run   leader r R RunClass   leader i m ImplementMethods   leader e e ShowErrorDescription   leader e n GotoNextError   leader R :source ~/.</description>
    </item>
    
  </channel>
</rss>