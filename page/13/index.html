<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>I'm company</title><meta name=keywords content="Java,Tool,Emacs,Mac"><meta name=description content="Everyone is a company."><meta name=author content="Me"><link rel=canonical href=http://blog.imcompany.cn/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.imcompany.cn/index.xml title=rss><link rel=alternate type=application/json href=http://blog.imcompany.cn/index.json title=json><link rel=alternate hreflang=en href=http://blog.imcompany.cn/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://blog.imcompany.cn/"><meta property="og:site_name" content="I'm company"><meta property="og:title" content="I'm company"><meta property="og:description" content="Everyone is a company."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="I'm company"><meta name=twitter:description content="Everyone is a company."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"I'm company","url":"http://blog.imcompany.cn/","description":"Everyone is a company.","logo":"http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E","sameAs":["https://x.com/","peng051410@126.com","https://github.com/peng051410"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://blog.imcompany.cn/ accesskey=h title="Home (Alt + H)"><img src=http://blog.imcompany.cn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.imcompany.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.imcompany.cn/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://blog.imcompany.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/peng051410/today_i_learn title=Til><span>Til</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之装饰器</h2></header><div class=entry-content><p>说明 装饰器设计模式是使用比较频繁的设计模式，它在不改变原物体的情况对原物体实现了功能的增加，原物体还是一个可单独使用的个体。在JAVA的类库中应该会马上想到IO类，各种的InputStrem，OutputStrem。
装饰器模式 在用户登录的中过程，我们需要对用户输入的密码进行加密操作，在设计时会提供好多种加密的算法，例如简单的BASE64加密，复杂的如MD5、DSA加密。直接把用户的密码存入数据库是真的在耍流氓。在使用这些算法时，我们想灵活的使用，比如使用完简单加密还可以再进行一下MD5的加密。针对这样的需求，可以使用装饰器模式进行实现。大体思路如下：
加密接口，定义加密方法。 在装饰器中，最原始的被装饰者是目标实现，它们一般会实现加密定义的具体方法。 装饰者会针对目标对象进行装饰，所以它要同样实现加密接口的方法，一般情况下这个装饰器会定义为抽象的形式，在这个装饰器父类中维护着对目标对象的引用。 具体装饰器继承抽象装饰器来实现对目标对象的真正装饰操作。 以上的情况在代码上体现为如下形式：
加密接口 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public interface Encryptor { void encrypt(); } 具体加密类，实现加密处理接口 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public class ConcreteEncryptor implements Encryptor { @Override public void encrypt() { System.out.println("base encrypt!"); } } 抽象加密装饰器 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public abstract class EncryptDecorator implements Encryptor { private Encryptor encrypt; public EncryptDecorator(Encryptor encrypt) { this.encrypt = encrypt; } @Override public void encrypt() { encrypt.encrypt(); } } 上面的抽象装饰器实现的加密接口，在这个类中维护加密接口的实体，加密方法直接调用其维护实体的加密方法。
...</p></div><footer class=entry-footer><span title='2018-07-02 20:09:14 +0800 CST'>July 2, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>236 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之装饰器" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之适配器</h2></header><div class=entry-content><p>说明 在前面的文章中介绍了一些关于支付相关的功能，现在转向登录，在早些时期的系统登录就是用户使用用户名与密码进行注册，注册成功后就可以进行登录了。随着时代的发展，出现很多三方的平台，它们对外提供了获取平台用户信息的功能，例如微信、qq、微博等三方登录，在接入这些三方登录时都是遵循相应的规则，老的登录的方式需要保留，对接新的登录方式还想要使用老的登录服务，这样可以使用适配器模式来实现。
适配器模式 比如我们平常使用的转接头一样，就是一种适配器的模式。它使两个不相关的物体很好的关联在一起。对于要接入的新的登录方式，首先定义新的三方登录的接口，定义要使用的三方登录方式，如下代码示例：
package cn.imcompany.adapter; /** * Created by tomyli on 2018/6/22. * Github: https://github.com/peng051410 */ public interface ThirdLogin { void wechatLogin(String accessToken); void qqLogin(String accessToken); void sinaLogin(String accessToken); } 如上定义了微信、qq、微博三种登录方式，它们都是使用accessToken来进行认证，经用户同意后获取相应的用户的信息调用方使用。下面来进行具体的实现：
package cn.imcompany.adapter; /** * Created by tomyli on 2018/6/22. * Github: https://github.com/peng051410 */ public class ThirdLoginAdapter implements ThirdLogin { private LoginService loginService; public ThirdLoginAdapter() { this.loginService = new LoginService(); } @Override public void wechatLogin(String accessToken) { System.out.println("微信获取用户信息"); loginService.login(accessToken, null); } @Override public void qqLogin(String accessToken) { System.out.println("qq获取用户信息"); loginService.login(accessToken, null); } @Override public void sinaLogin(String accessToken) { System.out.println("微博获取用户信息"); loginService.login(accessToken, null); } } 在上面的实现，并没有重新写登录的逻辑，除了要调用三方平台的代码，登录的功能是直接使用老的登录服务实现的。在这个实现类中引用了老的服务，然后使用其已经非常成熟的功能来完成登录的操作。这样以最少的代码达到了新的需求也使老的服务可以正常运行。免去了很多测试的功能点。这种适配器叫做对象适配器。
...</p></div><footer class=entry-footer><span title='2018-06-26 21:30:17 +0800 CST'>June 26, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>217 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之适配器" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gua-pei-qi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之模板模式</h2></header><div class=entry-content><p>说明 在一般实现处理用户支付订单时，通常都会在一个单独的回调项目中来处理用户的支付方式回调。一般情况下，回调的处理过程都是相似的，大体的步骤就是获取参数->验证参数->验证签名->验证支付状态（可选）->订单状态为成功增加用户的充值金额。具体的过程由于不同的支付方式不同而处理的不同。这种需求可以使用模板的模板模式来实现。
模板设计模式实现 模板模式就是由一个类来声明整个处理流程的步骤，具体的实现由各个实现类来进行实现。处理的流程不变，变是就是里面具体的实现。针对上面的支付回调，可以声明一个抽象类来声明具体的流程方法，代码如下：
package cn.imcompany.callback; import java.util.Map; /** * Created by tomyli on 2018/6/21. * Github: https://github.com/peng051410 */ public abstract class PayCallback { public abstract Map&lt;String, String> getParam(); public abstract boolean checkParam(Map&lt;String, String> param); public abstract boolean validSign(); /** * 定义了一个钩子方法来让子类控制流程实现 * @return true：强制返回，false：不强制返回 */ public boolean forceReturn() { return false; } public String doService() { Map&lt;String, String> map = getParam(); if (!checkParam(map)) { return "param fail"; } if (!validSign()) { return "sign fail"; } if (!map.get("status").equals("success")) { if (forceReturn()) { return "order fail"; } } return "success"; } } 在上面的PayCallback类中声明了getParam(获取参数)，checkParam（验证参数），validSign（验证签名），验证支付状态四个步骤，具体的支付回调类要来实现这里声明的方法即可。下面是一个微信支付的回调类的代码实现：
...</p></div><footer class=entry-footer><span title='2018-06-25 21:06:17 +0800 CST'>June 25, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>224 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之模板模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-mo-ban-mo-shi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之策略模式</h2></header><div class=entry-content><p>说明 策略模式是设计模式中使用频率很高的模式，主要的就是实现对行为的包装，达到结果的方式有多种，使用者可以选择任何一个方式来得到想要结果，在增加新的方式时更加的方便与灵活。它是为了适应算法的灵活性而产生的。
策略模式实现 以常用的购物为例，一般情况下购物分为浏览商品，下单，支付。在支付时消费者可以选择多种不同的支付方式，如支付宝、微信、京东支付、银联支付等。在支付中流程就可以使用到策略模式，网站为用户提供了这些支付方式可供选择，用户只需要选择自己喜欢的支付方式来进行充值就可以得到商品了。在一般情况下都会定义一个抽象类来定义支付的一些行为，如金额，商品简介等信息。实现的抽象类如以下定义：
package cn.imcompany.pay; /** * Created by tomyli on 2018/6/20. * Github: https://github.com/peng051410 */ public interface Payment { boolean pay(String param); } 这样就定义了支付方式的行为，剩下的就由不同的支付方式来进行实现，比如支付宝支付、微信支付，示例代码如下：
package cn.imcompany.pay; /** * Created by tomyli on 2018/6/20. * Github: https://github.com/peng051410 */ public class AliPay implements Payment { @Override public boolean pay(String param) { System.out.println("AliPay"); return true; } } public class WechatPay implements Payment { @Override public boolean pay(String param) { System.out.println("WechatPay"); return true; } } 要是再增加一种支付方式则可以实现Payment接口进行实现就可以了，一般情况下会有一个维护支付方式的常量类，由它来维护可用的支付方式。这个常量类的简化代码如下：
...</p></div><footer class=entry-footer><span title='2018-06-20 07:04:56 +0800 CST'>June 20, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>159 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之策略模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-ce-lue-mo-shi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之工厂模式</h2></header><div class=entry-content><p>说明 工厂设计模式是23种设计模式中使用频率非常高的，属于创建型模式。主要特点是实现了实体创建与使用的分离，达到了解耦的目的。工厂设计模式一般分为简单工厂、工厂方法、抽象工厂。
前提准备 4年一界世界杯即将到来，啤酒厂商又要大嫌一笔。我们先准备好要生产的啤酒实体。
package cn.imcompany; /** * Created by tomyli on 2018/5/27. * Github: https://github.com/peng051410 */ public interface Beer { String getName(); } public class JinShiBai implements Beer { @Override public String getName() { return "金士百"; } } public class QingDao implements Beer { @Override public String getName() { return "青岛"; } } public class BaiWei implements Beer { @Override public String getName() { return "百威"; } } 在上面定义三种啤酒，它们都由抽象类Beer继承而来。下面使用简单工厂来给消费者提供啤酒。
...</p></div><footer class=entry-footer><span title='2018-06-12 21:33:40 +0800 CST'>June 12, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>413 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之工厂模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-gong-han-mo-shi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之原型模式</h2></header><div class=entry-content><p>特点 原型设计模式就是系统中产生的每一个对象都不相同，通过原型来创建新的对象，原型模式属于创建型模式。
实现方式 一般情况可以通过对象克隆的方式来根据一个对象创建出来多个对象，每个对象在内存占用的内存地址都不一样。在JAVA中克隆又分为浅克隆与深克隆。
浅克隆 JAVA中是按值进行传递。实现克隆的方式就是实现Cloneable接口，这样就可以重写Object对象的clone方法来进行对象的克隆。代码如下：
/** * Created by tomyli on 2018/5/30. * Github: https://github.com/peng051410 */ public class Apple implements Cloneable { public String name; public double weight; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } 测试代码如下：
public static void main(String[] args) throws Exception { Apple apple = new Apple(); apple.name = "apple"; apple.weight = 2.23; try { Apple clone = (Apple)apple.clone(); System.out.println(clone == apple); } catch (Exception e) { e.printStackTrace(); } } 测试代码中clone与apple是两个完全不同的对象，这样就通过apple这个原型创建出来一个全新的对象。但是这里存在一个问题，现在Apple对象中只包含了值类型的成员变量，如果包含了其它对象会克隆也会成功吗？我们在Apple对象中增加一个Stone对象的集合，代码：
...</p></div><footer class=entry-footer><span title='2018-06-09 17:12:41 +0800 CST'>June 9, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>195 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之原型模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-yuan-xing-mo-shi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之单例模式</h2></header><div class=entry-content><p>特点 单例模式就是确保在系统中只在一个实例提供功能。单例有好几种写法，主要有饿汉式、懒汉式、静态方法内部类、注册式单例。
饿汉式 饿汉式单例就是在类定义时就已经将实例进行了初始化，在系统调用时可以直接返回不需要再实例化。示例代码如下：
public class Hungry { private Hungry() { } private static final Hungry INSTANCE = new Hungry(); public static Hungry getInstance() { return INSTANCE; } } 饿汉式的优点是提前进行初始化，线程安全。缺点是在系统未调用的情况下占用了内存空间，是以空间换取时间的样例
懒汉式 懒汉式就是在使用才对对象实例进行初始化，达到了延迟加载的目的。示例代码如下：
public class LazyOne { private LazyOne() { } private static LazyOne instance = null; public static LazyOne getInstance() { if (instance == null) { instance = new LazyOne(); } return instance; } } 懒式式优化点使用时实例化，延迟加载。缺点是存在线程安全问题
...</p></div><footer class=entry-footer><span title='2018-06-05 16:36:08 +0800 CST'>June 5, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>512 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之单例模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dan-li-mo-shi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Idea中vim键的映射</h2></header><div class=entry-content><p>Idea中IdeaVim插件可以让我们在Idea中使用vi的按键来进行操作，但是原生的配置只带有一些基本的移动操作。需要在~/.ideavimrc文件中进行Idea的动作映射来发挥它们的最大力量。
Key Description kj gt VimBack gT VimForward gd GotoDeclaration gf GotoTypeDeclaration gh QuickJavaDoc gs GotoSymbol gi GotoImplementation gu FindUsages gj IntroduceVariable leader w d ActivateDatabaseToolWindow leader ' ActivateTerminalToolWindow leader w r ActivateRedisServersToolWindow leader w m ActivateMavenProjectsToolWindow leader w a HideActiveWindow leader w w HideAllWindows leader w p ActivateProjectToolWindow leader w s ActivateStructureToolWindow leader w v ActivateVersionControlToolWindow leader w h h Go to left window leader w l l Go to right window leader w k k Go to window up leader w j j Go to window down leader w V v Split Window Vertically leader w - s Split Winodw Horizontally leader w c c Close current window leader w o o Close all window except current leader GotoAction leader c c GotoClass leader c r CopyReference leader c p CopyPaths leader f f GotoFile leader f d DashLauncherAction leader b b RecentFiles leader b p FileStructurePopup leader b u ReopenClosedTab leader d d Debug leader d D DebugClass leader d j JRebel leader l l EvaluateExpression leader t t ToggleLineBreakpoint leader r r Run leader r R RunClass leader i m ImplementMethods leader e e ShowErrorDescription leader e n GotoNextError leader R :source ~/.ideavimrc leader g s Vcs.QuickListPopupAction leader r p ReplaceInPath zO ExpandAllRegions zo ExpandRegion zc CollapseRegion zC CollapseAllRegions fj emacsIDEAs.AceJump fw emacsIDEAs.AceJumpWord ff CommentByLineComment fb CommentByBlockComment gd GotoDeclaration gf GotoTypeDeclaration gh QuickJavaDoc gs GotoSymbol gi GotoImplementation gu FindUsages gj IntroduceVariable ,, ReformatCode ,r RenameElementi Back Forward leader R reload ~/.ideavimrc leader a l :actionlist leader g s Vcs.QuickListPopupAction leader s p FindInPath leader r p ReplaceInPath , c r Revert change , c t Close other tab</p></div><footer class=entry-footer><span title='2018-05-14 14:48:33 +0800 CST'>May 14, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>272 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Idea中vim键的映射" href=http://blog.imcompany.cn/post/chang-yong-de-ideacha-jian/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>title = “2020-ARTS-打卡第十五天” lastmod = 2026-01-26T15:43:06+08:00 tags = [“arts”, “java”, “leetcode”] categories = [“arts”] draft = false author = “tomyli” +++
Algorithm 题目 题目描述 求一个数的N次幂
题目解答 public class MyPow { public double doPow(double x, int n) { if(x == 0) { return 0; } if(x == 1 || n == 0) { return 1; } if(n == 1) { return x; } long b = n; if(b &lt; 0) { x = 1 / x; b = -b; } double res = 1.0; while(b > 0) { if((b & 1) == 1) { res *= x; } x *= x; b >>= 1; } return res; } } Review Tip Share</p></div><footer class=entry-footer><span>1 min</span>&nbsp;·&nbsp;<span>111 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to " href=http://blog.imcompany.cn/post/2020-arts-015/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://blog.imcompany.cn/page/12/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=http://blog.imcompany.cn/>I'm company</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>