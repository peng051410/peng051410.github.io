<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | I'm company</title><meta name=keywords content><meta name=description content="Everyone is a company."><meta name=author content="Me"><link rel=canonical href=http://blog.imcompany.cn/tags/java/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.imcompany.cn/tags/java/index.xml title=rss><link rel=alternate hreflang=en href=http://blog.imcompany.cn/tags/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://blog.imcompany.cn/tags/java/"><meta property="og:site_name" content="I'm company"><meta property="og:title" content="Java"><meta property="og:description" content="Everyone is a company."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java"><meta name=twitter:description content="Everyone is a company."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://blog.imcompany.cn/ accesskey=h title="Home (Alt + H)"><img src=http://blog.imcompany.cn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.imcompany.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.imcompany.cn/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://blog.imcompany.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/peng051410/today_i_learn title=Til><span>Til</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://blog.imcompany.cn/>Home</a>&nbsp;»&nbsp;<a href=http://blog.imcompany.cn/tags/>Tags</a></div><h1>Java
<a href=/tags/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020-ARTS-打卡第十一天</h2></header><div class=entry-content><p>Algorithm 题目 题目描述 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。 239 sliding-window-maximum
题目解答 一般与滑动窗口有关的问题都可以使用双端队列来处理。
import java.util.ArrayDeque; import java.util.List; import java.util.ArrayList; public class MaxSlidingWindow { private ArrayDeque&lt;Integer> window = new ArrayDeque&lt;>(); public int[] slidingWindowMax(int[] nums, int k) { if(nums.length == 0) { return new int[0]; } List&lt;Integer> res = new ArrayList&lt;>(); for(int i = 0; i &lt; nums.length; i++) { if(i >= k && window.getFirst() &lt;= i - k) { window.pollFirst(); } while(!window.isEmpty() && nums[window.getLast()] &lt; nums[i]) { window.pollLast(); } window.add(i); if(i >= k - 1) { res.add(nums[window.getFirst()]); } } return res.stream().mapToInt(i->i).toArray(); } } Review Consistent_hashing一致性Hash算法。
...</p></div><footer class=entry-footer><span title='2026-01-30 11:00:31 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>134 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 2020-ARTS-打卡第十一天" href=http://blog.imcompany.cn/post/2020-arts-011/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020-ARTS-打卡第十二天</h2></header><div class=entry-content><p>Algorithm 题目 题目描述 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。242 valid anagram
题目解答 可以使用先排序后判断的方法来实现，这样的时间复杂度为O(nlog(n))。更好的方法是借助Hash表来实现，可以达到O(n)的时间复杂度。
public class ValidAnagram { public boolean isAnagram(String s, String t) { if (null == s || null == t || s.length() != t.length()) { return false; } Map&lt;Character, Integer> map = new HashMap&lt;>(); final char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { final char key = s.charAt(i); map.put(key, map.getOrDefault(key, 0) + 1); final char key1 = t.charAt(i); map.put(key1, map.getOrDefault(key1, 0) - 1); } for (Map.Entry&lt;Character, Integer> entry : map.entrySet()) { if (0 != entry.getValue()) { return false; } } return true; } } Review 你可能不知道的SHELLCoolShell左耳朵耗子2012年的关于强大Shell的文章，里面列出了很多有用的命令，看完后收获颇丰。针对实际使用场景，列出我认为暂时可以直接使用的一些操作命令。
...</p></div><footer class=entry-footer><span title='2026-01-30 11:00:28 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>150 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 2020-ARTS-打卡第十二天" href=http://blog.imcompany.cn/post/2020-arts-012/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020-ARTS-打卡第十三天</h2></header><div class=entry-content><p>Algorithm 题目 题目描述 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。答案中不可以包含重复的三元组。
题目解答 import java.util.ArrayList; import java.util.Arrays; import java.util.List; class Solution { public List&lt;List&lt;Integer>> threeSum(int[] nums) { List&lt;List&lt;Integer>> result = new ArrayList&lt;>(); if(null == nums || nums.length &lt; 3) { return result; } Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i ++) { if(nums[i] > 0) { break; } if(i > 0 && nums[i] == nums[i - 1]) { continue; } int L = i + 1; int R = nums.length - 1; while (L &lt; R) { int target = nums[i] + nums[L] + nums[R]; if (target == 0) { result.add(Arrays.asList(nums[i], nums[L], nums[R])); while (L &lt; R && nums[L] == nums[L + 1]) L++; while (L &lt; R && nums[R] == nums[R - 1]) R--; L++; R--; } else if (target &lt; 0) { L++; } else { R--; } } } return result; } 一共有三种解法，一是三层for循环，时间复杂度为O(n3)；二是二层for循环外加Hash表，时间复杂度为O(n2)，增加了空间复杂度O(n);第三种就是上面的解法，排序后从两侧开始匹配，时间复杂度为O(n2)，空间复杂度为O(1)
...</p></div><footer class=entry-footer><span title='2026-01-30 11:00:23 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>229 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 2020-ARTS-打卡第十三天" href=http://blog.imcompany.cn/post/2020-arts-013/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020-ARTS-打卡第十四天</h2></header><div class=entry-content><p>Algorithm 题目 题目描述 98.验证二叉搜索树，给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的树 节点的右子树只包含大于当前节点的树 所有左子树及右子树自身也必须是二叉搜索树 题目解答 import java.util.Stack; public class ValidBST { public boolean isValidBST (TreeNode root) { Stack&lt;TreeNode> stack = new Stack&lt;>(); double inorder = -Double.MAX_VALUE; while (!stack.isEmpty() || root != null) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (inorder >= root.val) { return false; } inorder = root.val; root = root.right; } return true; } } 使用中序遍历(即左->根->右)来实现，从左至右进行比对，每次与上次保存的值进行对比，如果当前节点值比上次保存的值小，则可以判定此树不是二叉搜索树。时间复杂度为O(n)，空间复杂度为O(n)
...</p></div><footer class=entry-footer><span title='2026-01-30 11:00:15 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>126 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 2020-ARTS-打卡第十四天" href=http://blog.imcompany.cn/post/2020-arts-014/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC统一配置接口WebMvcConfigurer功能</h2></header><div class=entry-content><p>接口说明 WebMvcConfigurer是Spring提供的统一配置接口，用于自定义Spring MVC的配置，全局更改服务的行为，提供的可配置项： 方法名称 参数 用途 addArgumentResolvers(List&lt;HandlerMethodArgumentResolver> argumentResolvers) List&lt;HandlerMethodArgumentResolver> argumentResolvers 添加自定义的 HandlerMethodArgumentResolver 用于解析方法参数。 addCorsMappings(CorsRegistry registry) CorsRegistry registry 配置跨域资源共享 (CORS) addFormatters(FormatterRegistry registry) FormatterRegistry registry 添加自定义的格式化程序和转换器 addInterceptors(InterceptorRegistry registry) InterceptorRegistry registry 添加自定义的拦截器 addRequestMappings(RequestMappingInfo customization, Class&lt;Controller> controllerClass) RequestMappingInfo customization, Class&lt;Controller> controllerClass 关联自定义请求映射到具控制器类 addResourceHandlers(ResourceHandlerRegistry registry) ResourceHandlerRegistry registry 配置资源处理，如静态资源路径 addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler> returnValueHandlers) List&lt;HandlerMethodReturnValueHandler> returnValueHandlers 添加自定义的 HandlerMethodReturnValueHandler 用于处理方法返回值 addViewControllers(ViewControllerRegistry registry) ViewControllerRegistry registry 注册视图控制器 configureAsyncSupport(AsyncSupportConfigurer configurer) AsyncSupportConfigurer configurer 配置异步支持 configureContentNegotiation(ContentNegotiationConfigurer configurer) ContentNegotiationConfigurer configurer 配置内容协商策略 configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) DefaultServletHandlerConfigurer configurer 启用默认 Servlet 处理 configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver> exceptionResolvers) List&lt;HandlerExceptionResolver> exceptionResolvers 配置异常处理程序 configureMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) List&lt;HttpMessageConverter&lt;?>> converters 配置自定义的 HttpMessageConverter configurePathMatch(PathMatchConfigurer configurer) PathMatchConfigurer configurer 配置路径匹配规则 configureViewResolvers(ViewResolverRegistry registry) ViewResolverRegistry registry 配置视图解析器 extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver> exceptionResolvers) List&lt;HandlerExceptionResolver> exceptionResolvers 扩展异常处理程序 extendMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) List&lt;HttpMessageConverter&lt;?>> converters 扩展自定义的 HttpMessageConverter extendInterceptors(List&lt;HandlerInterceptor> interceptors) List&lt;HandlerInterceptor> interceptors 扩展拦截器 extendArgumentResolvers(List&lt;HandlerMethodArgumentResolver> argumentResolvers) List&lt;HandlerMethodArgumentResolver> argumentResolvers 扩展自定义的 HandlerMethodArgumentResolver 用于解析方法参数。 extendReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler> returnValueHandlers) List&lt;HandlerMethodReturnValueHandler> returnValueHandlers 扩展自定义的 HandlerMethodReturnValueHandler 用于处理方法返回值。 extendViewResolvers(List&lt;ViewResolver> viewResolvers) List&lt;ViewResolver> viewResolvers 扩展视图解析器 关联类 WebMvcConfigurationSupport EnableWebMvc 接口常用方法 接口提供了将近20个方法对Spring的配置进行调整，本次只针对常用的Rest接口开发相关内容进行展开学习研究
...</p></div><footer class=entry-footer><span title='2026-01-30 10:49:28 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>461 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC统一配置接口WebMvcConfigurer功能" href=http://blog.imcompany.cn/post/spring-webmvcconfigurer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JAVA中如何判断对象与类的关系之-instanceOf, Class.isInstance, Class.isAssignableFrom</h2></header><div class=entry-content><p>前言 在开发中，常常会碰到检查JAVA对象是不是指定类型的情况，在JAVA中提供了以下几种方法实现此类需求:
instanceOf Class.isInstance() Class.isAssignbleFrom() 今天对此三种实现进行具体学习，以加深理解并更好的使用
准备工作 先创建一个名为 Shape 的接口，一个实现了 Shape 接口的类 Triangle , 再定义一个继承 Triangle 类的类 IsoscelesTriangle
public interface Shape { } public class Triangle implements Shape { } public class IsoscelesTriangle extends Triangle { } 以上三个类的类图关系如下 instanceOf instanceOf 是JAVA中的一个关键字，用于判断 实例对象是否是指定类型的子类型 ，常用于类型转换(cast)之前进行判断，操作的元素是一个对象和一个类型
Shape shape = new Triangle(); Triangle triangle = new Triangle(); IsoscelesTriangle isoscelesTriangle = new IsoscelesTriangle(); Shape nonspecificShape = null; assertTrue(shape instanceof Shape); assertTrue(triangle instanceof Shape); assertTrue(isoscelesTriangle instanceof Shape); assertFalse(nonspecificShape instanceof Shape); assertTrue(shape instanceof Triangle); assertTrue(triangle instanceof Triangle); assertTrue(isoscelesTriangle instanceof Triangle); assertFalse(nonspecificShape instanceof Triangle); assertFalse(shape instanceof IsoscelesTriangle); assertFalse(triangle instanceof IsoscelesTriangle); assertTrue(isoscelesTriangle instanceof IsoscelesTriangle); assertFalse(nonspecificShape instanceof IsoscelesTriangle); 上面例子测试 instanceOf 左侧对象是否是右侧类型的实例类型
...</p></div><footer class=entry-footer><span title='2022-12-12 19:14:00 +0800 CST'>December 12, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>249 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to JAVA中如何判断对象与类的关系之-instanceOf, Class.isInstance, Class.isAssignableFrom" href=http://blog.imcompany.cn/post/java-check-object-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java枚举学习</h2></header><div class=entry-content><p>枚举 枚举是指包含指定个数特定类型的实例类，所有枚举类默认都继承 java.lang.Enum ，枚举类是可序列化、可比较的
public enum Person { MAN, WOMAN; } public static void main(String[] args) { System.out.println(Person.MAN); } MAN 枚举构造器 枚举中自动生成的无参构造器默认是private的 显示定义的构造器只能是私有或无访问符的，即枚举不可以从外部进行实例化 无参构造器 public enum Person { MAN(), WOMAN(); Person() {} } public static void main(String[] args) { for(Person person : Person.values()) { System.out.println(person); } } MAN WOMAN 带参构造器 public enum Person { MAN(1), WOMAN(2), UNKNOWN, ; Person() {} Person(int status) { this.status = status; } public int status; } public static void main(String[] args) { for(Person person : Person.values()) { System.out.println(person.status); } } 1 2 0 枚举类初始化 枚举类的初始化与一般类的初始化过程(静态代码块->构造器代码块->构造函数)不同，它的执行顺序为：实例构造器代码块->构造函数->静态常量代码块，以下代码进行演示
...</p></div><footer class=entry-footer><span title='2022-11-23 12:01:00 +0800 CST'>November 23, 2022</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>477 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Java枚举学习" href=http://blog.imcompany.cn/post/java-enum/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>让好代码生生不息-更好的使用String</h2></header><div class=entry-content><p>开发中常用的String操作 开发中经常用到的操作有：
格式化/日志格式化 字符串判断 字符串处理，常见的如处理字符串的第一个/最后一个字符 String.format String.format()是一个格式化的方法，使用%为前缀来表示要格式化的内容占位，一般的使用方法为：
String.format("test result is %s", "success"); 但是当要格式化的占位符与参数个数不同时会发生什么呢？
占位符个数与参数个数相同 如上代码，可以正常进行输出: test result is success
占位符个数少于参数个数 String.format("test result is %s", "success", "other"); 可以正常打印，输出结果为: test result is success
占位符个数多于参数个数 String.format("test result is %s %s %s", "success", "other"); 抛出了异常java.util.MissingFormatArgumentException: Format specifier ‘%s’
问题总结 为什么占位符数少于参数个数可以正常执行，而多于参数个数却报了异常？看JAVADOC发现，如果占位符个数少于参数个数，则多余的参数被忽略，如果多于参数个数，则在进行解析时会判断待处理占位符位置与参数个数，主要代码逻辑如下：
if (args != null && lasto > args.length - 1) throw new MissingFormatArgumentException(fs.toString()); 所以在使用String.format方法 切记 要参数个数多于待解析占位符的个数，这种问题常因为Copy操作后，处理了部分参数而忘记对应处理占位符
替换方案
目前看到很多的老代码打印日志时大都使用String.format()，可以改成slf4j的{} 还可以使用Apache common utils中的StringUtils.joinWith()或者Google guava的Joiner连接器 Apache commons utils-StringUtils 在StringUtils中有一个isNumeric方法，用来判断字符串是不是数字，那下面的代码会返回什么呢？
...</p></div><footer class=entry-footer><span title='2021-08-23 14:04:09 +0800 CST'>August 23, 2021</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>221 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 让好代码生生不息-更好的使用String" href=http://blog.imcompany.cn/post/best-code-string/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>让好代码生生不息-更好的对待NULL</h2></header><div class=entry-content><p>什么样的代码是好代码 易读的代码，行云流水的代码
JAVA中的NULL处理 众所周知，在Java代码中总是少不了一堆的判null逻辑，在代码bug中，NullPointerException出镜率也是非常高的，尤其是现在的主流分布式架构，一个web接口要调用后端的N个RPC服务来实现功能，基于防御编程的思想，判null就更重要了
在处理NULL时怎么做更好 IDE 既然无法避免null，IDE就给程序员增加了可以快速判断空的功能，比如在IDEA中，可以使用Postfix功能，在对象上o使用.nn来快速输入if(o != null) {}
JAVA基础类库 近期的JDK版本也针对null判断增加了一些实用的方法
Objects类 JAVA8在Objects工具提供了isNull()和nonNull()方法，JAVA9又增加了requireNonNullElse()和requireNonNullElseGet()来给待处理对象增加设置默认值的方法
知名三方库 Apache common utils中提供了非常多的判空工具类，如针对String操作的StringUtils类和针对集合操作的CollectionUtils、MapUtils、ListUtils、SetUtils，这几个类都有一些典型的方法来进行判空处理，通用的方法如下：
StringUtils isEmpty()/isNotEmpty()
判断String是否为空/不空
isBlank()/isNoneBlank()
判断String是否为空/不空，这类方法还会判断实际值是否为空串
defaultString()
此方法允许在String为null时为返回空串
defaultIfBlank()/defaultIfEmpty()
此方法允许在String为空串或null时设置一个默认值
集合类Utils isEmpty()/isNotEmpty()
判断集合是否为空/不空
emptyIfNull()
这是一个很有用的方法，当传入对象为空时则返回设置的默认对象，可以很好的根治if处理null的问题，下面两段代码演示一下
正常情况下有if判断
List&lt;Object> values = rpcClient.getFromRpcList(); if(CollectionUtils.isNotEmpty(values)) { return values .forEach(System.out::println); } 使用emptyIfNull方法
return CollectionUtils.emptyIfNull(rpcClient.getFromRpcList()) .forEach(System.out::println); 这样保证了代码编写的连贯性，爽！
此方法在ListUtis、MapUtils、SetUtils中也有提供
defaultIfNull()
此方法允许在集合为null时设置一个默认值，也是可以链式操作
优秀的Coder 在编写通用方法时，对于有null返回的情况可以使用返回默认值来代替null
不返回空，以空对象来代替 比如返回一个new Object()
...</p></div><footer class=entry-footer><span title='2021-07-17 16:04:09 +0800 CST'>July 17, 2021</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>60 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 让好代码生生不息-更好的对待NULL" href=http://blog.imcompany.cn/post/best-code1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020-ARTS-打卡第十天</h2></header><div class=entry-content><p>Algorithm 题目 题目描述 设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。703 数据流中的第K大元素
题目解答 public class KthLargest { private PriorityQueue&lt;Integer> queue; private int k; public KthLargest(int k, int[] nums) { this.k = k; queue = new PriorityQueue&lt;>(k); for(int num : nums) { add(num); } } public int add(int val) { if(queue.size() &lt; k) { queue.offer(val); } else if (queue.peek() &lt; val) { queue.poll(); queue.offer(val); } return queue.peek(); } } Review 与程序员相关的CPU缓存知识这是左耳朵耗子的一篇微观技术分享，讲解了程序员要知道的关于CPU缓存的知识，并举例进行了说明。
...</p></div><footer class=entry-footer><span title='2020-03-14 15:10:09 +0800 CST'>March 14, 2020</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>136 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 2020-ARTS-打卡第十天" href=http://blog.imcompany.cn/post/2020-arts-010/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://blog.imcompany.cn/tags/java/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=http://blog.imcompany.cn/>I'm company</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>