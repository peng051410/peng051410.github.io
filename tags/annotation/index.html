<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Annotation | I'm company</title><meta name=keywords content><meta name=description content="Everyone is a company."><meta name=author content="Me"><link rel=canonical href=http://blog.imcompany.cn/tags/annotation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.imcompany.cn/tags/annotation/index.xml title=rss><link rel=alternate hreflang=en href=http://blog.imcompany.cn/tags/annotation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://blog.imcompany.cn/tags/annotation/"><meta property="og:site_name" content="I'm company"><meta property="og:title" content="Annotation"><meta property="og:description" content="Everyone is a company."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Annotation"><meta name=twitter:description content="Everyone is a company."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://blog.imcompany.cn/ accesskey=h title="Home (Alt + H)"><img src=http://blog.imcompany.cn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.imcompany.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.imcompany.cn/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://blog.imcompany.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/peng051410/today_i_learn title=Til><span>Til</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://blog.imcompany.cn/>Home</a>&nbsp;»&nbsp;<a href=http://blog.imcompany.cn/tags/>Tags</a></div><h1>Annotation
<a href=/tags/annotation/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Conditional</h2></header><div class=entry-content><p>注解说明 @Conditional 是 Spring 提供的用于判断是否对 Bean 注入的条件注解(在4.0后版本引入)，只有满足了所有的条件，一个 bean 才会被注册成功并使用。此注解可标注在类上、元注解上、@Bean方法上，通常与 @Configuration 注解配合使用，标识在 @Configuration 注解上的 @Conditional 会影响此配置类的所有 @Bean 注解方法、@Import 注解和@ComponentScan 注解。另需注意 @Conditional 注解不支持继承
对于标注在元注解上的样例，可查看 SpringBoot 项目下的 org.springframework.boot.autoconfigure.condition 包以 ConditionalOn 开头的类
注解属性 此注解只有一个属性 value ，返回类型为 Class 数组，它用来配置所有的 Condition 类信息
Condition 是 Spring 提供的一个接口，它提供了 matches 方法来提供判断的依据逻辑，对于其参数 ConditionContext 提供了丰富的上下文信息
测试代码 @Configuration @ComponentScan(basePackages = "cn.imcompany.bean.condition") public class MyConfiguration { @Bean @ConditionalOnDate public MyBean myBean() { return new MyBean(); } @Bean public MyBean2 myBean2() { return new MyBean2(); } @Bean @Conditional(ConfigPropertyCondition.class) public MyBean5 myBean5() { return new MyBean5(); } } @Configuration @Conditional(ConfigPropertyCondition.class) public class MyConfigConfiguration { @Bean public MyBean3 myBean3() { return new MyBean3(); } @Bean public MyBean4 myBean4() { return new MyBean4(); } } public class MyDateCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { LocalDateTime now = LocalDateTime.now(); int minute = now.getMinute(); return minute % 2 == 0; // 每隔两分钟满足条件 } } @Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.METHOD}) @Documented @Conditional(MyDateCondition.class) public @interface ConditionalOnDate { } public class ConfigPropertyCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return "true".equals(System.getProperty("my.config.property")); } } public class Main { public static void main(String[] args) { System.setProperty("my.config.property", "true"); AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfiguration.class); for (String beanDefinitionName : context.getBeanDefinitionNames()) { System.out.println("beanDefinitionName = " + beanDefinitionName); } } } 源码阅读 对于 Configuration 类条件处理分为两个阶段：
...</p></div><footer class=entry-footer><span title='2025-06-18 15:00:00 +0800 CST'>June 18, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>333 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Conditional" href=http://blog.imcompany.cn/post/spring-@conditional/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Bean</h2></header><div class=entry-content><p>注解说明 @Bean 是Spring的一个核心注解，通常与 @Configuration 注解一起使用，用于标记一个方法，方法返回的实体做为Spring管理的一个Bean，通过此注解可以使用JAVA的特性配置对象。默认情况下Bean名字为方法名，也支持通过属性进行配置
属性说明 name 自定义Bean的名称，支持配置多个名称，不配置默认为方法名称
initMethod 配置实例初始化方法，在Bean实例化被调用，默认为空
destroyMethod 配置实例销毁方法，默认值为 (inferred) 即会根据返回的Bean尝试查找识别对象的销毁方法 close 或者 shutdown(限制只查找public无参方法)，如返回一个 BasicDataSource 实例，会默认查找 close() 方法进行注册，如果不想Spring进行此操作，需要将此值设置为: destroyMethod="" (此配置对 DisposableBean 回调不生效)
核心逻辑在 DisposableBeanAdapter#inferDestroyMethodsIfNecessary() 方法中
与其它注解的关联 @Bean 与XML配置方式中的 &lt;bean> 标签不同，它使用与其它注解组合的方式来实现类型 Scope 或者懒加载的功能，具体可组合注解如下：
@Profile @Scope @Lazy @DepednsOn @Primary @Order @Description(给注解bean详细描述，此注解的值会保存在 BeanDefinition 实例上) @Conditional 接口默认方法定义Bean Spring 支持在接口中使用默认方法的方式进行bean的定义，方便子类配置类直接复用，示例代码:
public interface BaseConfig { @Bean default MyBean3 myBean3() { return new MyBean3(); } } @Configuration public class AppConfig implements BaseConfig { } 源码阅读 Bean注解配置实例化 由于@Bean通常与@Configuration 一起使用，核心逻辑在 refresh 阶段，定位代码发现在 ConfigurationClassParser#doProcessConfigurationClass() 方法进行对 @Bean 标识方法的解析
...</p></div><footer class=entry-footer><span title='2025-06-17 17:56:39 +0800 CST'>June 17, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>191 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Bean" href=http://blog.imcompany.cn/post/spring-@bean/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Import</h2></header><div class=entry-content><p>注解说明 @Import 注解用于标识多个需要导入的 Component 类，支持导入 @Configuration 类， ImportSelector 与 ImportBeanDefinitionRegistrar 实现，与 AnnotationConfigApplicationContext.register() 方法实现的功能类似。此注解常见的实践方式是标注在 EnableXXXX 注解上，用于开启某些功能，在开启功能时就需要通过 @Import 注解来选择导入哪些类的定义
属性说明 此注解只有一个属性 value，返回 Class[] ，用于标识导入的类
Class类型 @Configuration标识的类 对于不同功能的配置使用多个 @Configuration 标识，由一个类来 Import 另一个 类的配置，来达到复用的效果
@Configuration public class MyConfig2 { @Bean public MyBeanD myBeanD() { return new MyBeanD(); } } @Configuration @Import({MyConfig2.class}) public class MyConfig { } ImportSelector实现类 所有的 ImportSelector 实现都需要实现它的 selectImports 方法，来返回要导入的bean类名称集合 public class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{MyBeanA.class.getName()}; } } 在 ImportSelector 可以通过Aware或者构造器注入的方式使用 Spring中的容器组件：
...</p></div><footer class=entry-footer><span title='2025-06-17 17:32:55 +0800 CST'>June 17, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>245 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Import" href=http://blog.imcompany.cn/post/spring-@import/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Value</h2></header><div class=entry-content><p>注解说明 @Value 是Spring提供用于处理属性与表达式注入的注解，可标注在字段、方法或构造器的参数上，并且支持动态解析SpringMVC中的方法参数。支持注入方式：
直接注入如: @Value(“test”) ${my.app.myProp} 属性注入 #{systemProperties.myProp} SpEL表达式 它提供了不同的配置源(属性文件、系统属性)的注入
注解属性 @Value 注解只有一个属性 value ，表示要注入的实际值的表达式，支持属性与SpEL表达式两种方式 测试代码 以下测试代码MyController的username的注入值为: tomyli，而不是配置文件中的admin
@Controller public class MyController { @Value("${USER}") @Getter private String username; } @Configuration @ComponentScan(basePackages = "cn.imcompany.bean.autowired") @PropertySource("classpath:application.properties") public class MyConfiguration { } public class Main { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfiguration.class); MyController myController = context.getBean(MyController.class); System.out.println(myController.getUsername()); // tomyi } } application.properties配置文件 USER=admin 源码阅读 @Value 注解的处理由 AutowiredAnnotationBeanPostProcessor 类负责，与处理 @Autowired 注解的类为同一个PostProcessor。主要的处理逻辑实现在 DefaultListableBeanFactory#doResolveDependency 方法，对于 @Value注解的处理主要集中在第2步，解析@Value的操作主要分为3步 ...</p></div><footer class=entry-footer><span title='2025-06-10 16:00:00 +0800 CST'>June 10, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>170 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Value" href=http://blog.imcompany.cn/post/spring-@value/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Autowireid</h2></header><div class=entry-content><p>注解说明 @Autowired 是Spring框架的核心注解，用于自动装载构造器、字段、set方法、配置方法上的依赖，它是 JSR-330 @Inject 注解的替代，支持配置 依赖是否必须 选项
属性说明 此注解只有一个属性 required ，默认为 true 表示待注入组件必须存在
注解注入规则说明 构造器注入 如果一个类声明了多个构造器且没有一个显式标注 @Autowired，则Spring会使用默认的构造方法进行装载 如果一个类只声明了一个构造器，不管有没有标注 @Autowired 注解它都会被直接使用 多参数可以配置多个required属性，对于可选注入，可以声明为 Java8 的 Optional 类型 对于可选注入也可以使用 JSR-305 的 javax.annotation.Nullable 注解
字段注入 字段在构造器之后，配置方法注入之前进行自动注入
字段注入支持组件自引用(self references)
方法注入 方法注入不限制方法名与参数个数，所有参数会被Spring进行匹配注入
参数注入 目前只在 spring-test 模块中有效，其它地方使用会被忽略
数组/集合注入 Spring通过匹配数组/集合的值进行注入，Map的key必须为String类型，支持集合中元素的Order配置
不支持 BeanPostProcessor 或者 BeanFactoryPostProcessor 因为真实的注入动作发生在 BeanPostProcessor 阶段，所以不能在 BeanPostProcessor 或者 BeanFactoryPostProcessor 中使用此注解
源码阅读 在Spring中，处理 @Autowired 注解对应的类为 AutowiredAnnotationBeanPostProcessor ，又是一个Bean后置处理器
对于此类，需要关注其实现的两个接口类 MergedBeanDefinitionPostProcessor (运行时合并Bean的定义回调接口)和 InstantiationAwareBeanPostProcessor (在Bean实例化前后进行处理后置处理器)
MergedBeanDefinitionPostProcessor 主要是为了在真正bean实例化前准备缓存的bean元数据 InstantiationAwareBeanPostProcessor Bean实例化回调接口，通常用于为bean创建代理 测试代码 @Service public class MyService { } @Controller public class MyController { @Autowired MyService myService; public void showService() { System.out.println("myService = " + myService); } } @Configuration @ComponentScan(basePackages = "cn.imcompany.bean.autowired") public class MyConfiguration { } public class Main { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfiguration.class); MyController myController = context.getBean(MyController.class); myController.showService(); } } 元数据收集 调用栈信息如下：
...</p></div><footer class=entry-footer><span title='2025-06-06 16:00:00 +0800 CST'>June 6, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>267 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Autowireid" href=http://blog.imcompany.cn/post/spring-@autowired/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@CompnentScan</h2></header><div class=entry-content><p>注解说明 @ComponentScan 注解是Spring 提供的对组件进行扫描的注解指令，通常与 @Configuration 注解一起使用，支持在类上重复标注
注解能做什么？ 此注解支持以下重要特性:
自定义扫描的包范围 配置包含扫描组件的过滤器 配置排除组件的过滤器 是否使用默认过滤器 是否配置懒加载 源码分析 由于此注解通常与 @Configuration 注解一起使用，其解析的主要逻辑都是在 refresh 阶段的 invokeBeanFactoryPostProcessors 方法中，最终会定位到 ConfigurationClassParser#doProcessConfigurationClass() 方法中，在方法中可以看到对 ComponentScan 注解的操作逻辑了
对注解属性的解析 所有对属性的解析都在 ComponentScanAnnotationParser#parse() 方法中进行，此方法中会创建一个 ClassPathBeanDefinitionScanner 实例scanner，此实例初始化过程中会对默认的Filter进行加载
处理默认Filter主要是 JSR-250 与 JSR-330 API 增加的注解
然后会把配置的 includeFilter 和 excludeFilter 设置到 scanner 中，接着会对 basePackage 扫描包属性进行解析配置，如果配置了就添加，没有配置，默认就使用 @ComponentScan 注解标注类所在的包路径。解析完注解属性后，就开始了真正的扫描操作
扫描操作 扫描操作由 ClassPathBeanDefinitionScanner#doScan() 方法进行处理，此方法会调用 findCandidateComponents() 方法在给定的包下查找符合条件的组件，查找的任务由 scanCandidateComponents() 进行，该方法调用 isCandidateComponent() 方法，根据解析的includeFilter和excludeFilter 来选择满足条件的组件
这样扫描到所有满足条件的Bean后，会接着对这些Bean进行parse操作，直到注解再无其它依赖
注册Bean 扫描完所有Bean后，会调用 checkCandidate() 方法进行检查，检查当前要注册的Bean是否与已经注册过的Bean的定义是否兼容，如果冲突会报 ConflictingBeanDefinitionException 。检查没问题后，会调用 registerBeanDefinition() 方法对Bean进行注册，这个过程就涉及到Spring其它的生命周期了（这个后续专门学习总结），对于@ComponentScan 组件来说已经完成了它的使命
总结 最后以注解解析过程中的涉及的核心类做一下总结
常见问题 调整包结构后一些@Bean配置扫描不到了 调用启动类的包路径为最外层，这样可以扫描当前包及子包的配置 默认只扫描当前标注注解的包，可以通过配置 basePackage 属性指定扫描路径，配置后默认的扫描路径就不生效了 如何将未配置Spring相关组件注解的Bean纳入Spring管理? 可以通过配置 ComponentScan的includeFilter 来实现
...</p></div><footer class=entry-footer><span title='2025-05-15 16:29:33 +0800 CST'>May 15, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>99 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@CompnentScan" href=http://blog.imcompany.cn/post/spring-componentscan/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring学习之@Configuration</h2></header><div class=entry-content><p>@Configuration是什么？ @Configuration 是 Spring提供的一个用于配置与声明Bean与相应Bean之间依赖的注解，根据文档描述，此注解通常由 AnnotationConfigApplicationContext 上下文进行启动加载
@Configuration能做什么？ 先看一下此注解的声明，在此注解上标识了 @Component ，则证明此注解是一个 Component，拥有 @Component 注解的基础能力(可以被Spring容器自动扫描与加载)
上图标识了注解常用的配置方式，分类为以下几种
属性资源导入 引入其它配置类的配置 Value注入 Spring容器组件注入 支持Profile配置 注解属性 在Spring5.x版本中，只支持两个属性配置
value 配置注解的名称
proxyBeanMethods 是否代理增强(基于CGLIB)标识 @Bean 的方法，默认为true，保证声明的bean是单例共享的，而不是每一次通过方法调用都生成一个新的
此属性的两个值被定义为两种模式
full 模式(值为true) lite 模式(值为false) 源码分析 @Configuration 注解的解析类为 ConfigurationClassPostProcessor ，本次主要关注从 AnnotationConfigApplicationContext 启动后的整个处理过程， AnnotationConfigApplicationContext 启动分为三个阶段
先上一张三个阶段的涉及的主要类与调用关系图 初始化 初始化reader 此过程会实例化 AnnotatedBeanDefinitionReader 类，此类在实例化时会调用 AnnotationConfigUtils.registerAnnotationConfigProcessors 来注册解析配置的Processor，如果registry中没有包含 ConfigurationClassPostProcessor 类的定义，则会新new一个 ConfigurationClassPostProcessor 的Bean定义类
整体调用链路如下：
初始化scanner 此过程会实例化Bean定义扫描器 ClassPathBeanDefinitionScanner , 在此过程中主要会设置 Environment 和 ResourceLoader 相关信息
注册 注册阶段主要是对标注了 @Configuration 类(MyConfig)进行注册，以便Spring可以正常识别，主要逻辑在 AnnotatedBeanDefinitionReader#doRegisterBean 中，此方法会调用 BeanDefinitionReaderUtils.registerBeanDefinition 对此Bean进行注册
至此， @Configuration 类信息就注册到了 Spring 容器中
...</p></div><footer class=entry-footer><span title='2025-05-09 11:40:11 +0800 CST'>May 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>202 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Spring学习之@Configuration" href=http://blog.imcompany.cn/post/spring-configuration/></a></article></main><footer class=footer><span>&copy; 2026 <a href=http://blog.imcompany.cn/>I'm company</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>