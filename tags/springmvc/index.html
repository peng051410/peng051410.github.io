<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Springmvc | I'm company</title><meta name=keywords content><meta name=description content="Everyone is a company."><meta name=author content="Me"><link rel=canonical href=http://blog.imcompany.cn/tags/springmvc/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.imcompany.cn/tags/springmvc/index.xml title=rss><link rel=alternate hreflang=en href=http://blog.imcompany.cn/tags/springmvc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://blog.imcompany.cn/tags/springmvc/"><meta property="og:site_name" content="I'm company"><meta property="og:title" content="Springmvc"><meta property="og:description" content="Everyone is a company."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Springmvc"><meta name=twitter:description content="Everyone is a company."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://blog.imcompany.cn/ accesskey=h title="Home (Alt + H)"><img src=http://blog.imcompany.cn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.imcompany.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.imcompany.cn/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://blog.imcompany.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/peng051410/today_i_learn title=Til><span>Til</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://blog.imcompany.cn/>Home</a>&nbsp;»&nbsp;<a href=http://blog.imcompany.cn/tags/>Tags</a></div><h1>Springmvc
<a href=/tags/springmvc/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC实践之集成Sentinel限流功能</h2></header><div class=entry-content><p>背景 近期收到线上报警，发现个别新接口在同1s内被请求了接近上百次，对系统的稳定造成了一些影响，近期调研了一下通用的限流框架，打算将Sentinel的限流功能集成进新服务
Sentinel前置知识 Sentinel 限流主要涉及以下几方面
Resource 限流的资源，资源支持动态加载，核心类为： AbstractDataSource ，Sentinel 默认提供了市面常见的资源管理服务的实现，也可以自定义实现 Rule 对定义的 Resouce 应用的限流规则，基于QPS、响应时间与系统负载。Sentinel 是通过一系列的功能Slot来实现不同的统计/控制功能，对于限流功能对应的就是 FlowSlot
FlowSlot 的功能实现需要依赖前面的 NodeSelectorSlot 和 ClusterBuilderSlot 等统计Slot，有了统计信息才可以针对配置进行限流操作，这里面借用一张官方的实现图 各Slot默认的顺序也可以在代码中找到 核心处理逻辑 核心逻辑是在执行调用chain的捕获Blockexcption然后执行后续操作
集成步骤 借助SpringMVC中提供的 HandlerInterceptor 拦截器功能 与 Sentinel 提供的SpringMVC框架集成类库可以方便快速的实现限流功能
引入Sentinel SpringMVC Adapter &lt;dependency> &lt;groupId>com.alibaba.csp&lt;/groupId> &lt;artifactId>sentinel-spring-webmvc-adapter&lt;/artifactId> &lt;version>1.8.8&lt;/version> &lt;/dependency> 配置SentinelWebInterceptor Sentinel SpringMVC Adapter中提供了 SentinelWebInterceptor 来实现限流功能，这个 Interceptor 支持一些自定义的行为，主要通过 SentinelWebMvcConfig 来实现
SentinelWebMvcConfig 常用配置说明 SentinelWebMvcConfig 支持以下配置能力
urlCleaner
自定义对请求url的处理，比如厂商此次需要通过请求的设备id维度进行限流，对于其它的请求参数都进行忽略，最终可定义效果为: /api/v1/test/ping?did=6308103f1026acf274bbcc1b10001291551xxX
httpMethodSpecify
是否指定特定的Http请求方法，此设置是对资源的请求方法进行了细粒度的配置，默认为false不开启，配置为true后，会在设定好的资源名前加上请求的方法，类似效果: GET: /api/v1/test/ping?did=6308103f1026acf274bbcc1b10001291551xxX
blockExceptionHandler
被Block的请求异常处理器，对Block的请求进行自定义处理，可以设置返回的值，如果未配置则需要服务自己捕获 BlockException，可以通过配置 ExceptionHandler 进行统一处理
originParser
请求来源处理器，针对请求的来源进行处理，在配置资源的规则的可以使用此解析的origin细粒度控制，例如可以解析ip、用户做为请求 origin
...</p></div><footer class=entry-footer><span title='2026-01-30 10:48:47 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>131 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC实践之集成Sentinel限流功能" href=http://blog.imcompany.cn/post/spring-webmvc-interceptor-sentinel/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC实践之集成Sentinel限流功能</h2></header><div class=entry-content><p>背景 近期收到线上报警，发现个别新接口在同1s内被请求了接近上百次，对系统的稳定造成了一些影响，近期调研了一下通用的限流框架，打算将Sentinel的限流功能集成进新服务
Sentinel前置知识 Sentinel 限流主要涉及以下几方面
Resource 限流的资源，资源支持动态加载，核心类为： AbstractDataSource ，Sentinel 默认提供了市面常见的资源管理服务的实现，也可以自定义实现 Rule 对定义的 Resouce 应用的限流规则，基于QPS、响应时间与系统负载。Sentinel 是通过一系列的功能Slot来实现不同的统计/控制功能，对于限流功能对应的就是 FlowSlot
FlowSlot 的功能实现需要依赖前面的 NodeSelectorSlot 和 ClusterBuilderSlot 等统计Slot，有了统计信息才可以针对配置进行限流操作，这里面借用一张官方的实现图 各Slot默认的顺序也可以在代码中找到 核心处理逻辑 核心逻辑是在执行调用chain的捕获Blockexcption然后执行后续操作
集成步骤 借助SpringMVC中提供的 HandlerInterceptor 拦截器功能 与 Sentinel 提供的SpringMVC框架集成类库可以方便快速的实现限流功能
引入Sentinel SpringMVC Adapter &lt;dependency> &lt;groupId>com.alibaba.csp&lt;/groupId> &lt;artifactId>sentinel-spring-webmvc-adapter&lt;/artifactId> &lt;version>1.8.8&lt;/version> &lt;/dependency> 配置SentinelWebInterceptor Sentinel SpringMVC Adapter中提供了 SentinelWebInterceptor 来实现限流功能，这个 Interceptor 支持一些自定义的行为，主要通过 SentinelWebMvcConfig 来实现
SentinelWebMvcConfig 常用配置说明 SentinelWebMvcConfig 支持以下配置能力
urlCleaner
自定义对请求url的处理，比如厂商此次需要通过请求的设备id维度进行限流，对于其它的请求参数都进行忽略，最终可定义效果为: /api/v1/test/ping?did=6308103f1026acf274bbcc1b10001291551xxX
httpMethodSpecify
是否指定特定的Http请求方法，此设置是对资源的请求方法进行了细粒度的配置，默认为false不开启，配置为true后，会在设定好的资源名前加上请求的方法，类似效果: GET: /api/v1/test/ping?did=6308103f1026acf274bbcc1b10001291551xxX
blockExceptionHandler
被Block的请求异常处理器，对Block的请求进行自定义处理，可以设置返回的值，如果未配置则需要服务自己捕获 BlockException，可以通过配置 ExceptionHandler 进行统一处理
originParser
请求来源处理器，针对请求的来源进行处理，在配置资源的规则的可以使用此解析的origin细粒度控制，例如可以解析ip、用户做为请求 origin
...</p></div><footer class=entry-footer><span title='2025-04-25 17:53:54 +0800 CST'>April 25, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>131 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC实践之集成Sentinel限流功能" href=http://blog.imcompany.cn/post/spring-webmvc-interceptor/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC学习之HandlerMapping</h2></header><div class=entry-content><p>起因 新服务在处理不存在的url请求时，上报日志报错，具体错误信息： 根据报错信息找到相关代码 代码处做了对参数hanler的强制转换，但是真正传入的参数类型为 ResourceHttpRequestHandler 导致转换失败而报错，梳理一下，handler是在 自定义的日志Interceptor 的afterCompletion方法中由框架传入的 ResourceHttpRequestHandler 是什么? 查阅类文档，ResourceHttpRequestHandler是SpringMVC提供的处理静态资源的Handler，比如常见的js或者css文件。在当前前后端分离的分工下，对于REST服务开发，不会再使用这种方式提供对静态资源的访问，为什么请求了一个不存在的url，会使用静态资源的Hanlder来处理?
SpringMVC提供了哪些HandlerMapping? SpringMVC提供的HanlderMapping位于 org.springframework.web.servlet.handler 包下，主要包含
Mapping Desc RequestMappingHandlerMapping 处理@RequestMapping 注解映射关系 SimpleUrlHandlerMapping 使用URL模式匹配映射关系 BeanNameUrlHandlerMapping 基于Bean名匹配映射关系 SpringMVC 路径映射流程回顾 回顾一下SpringMVC的路径映射流程，通常的url请求的编码方式为:
@RequestMapping("/ping") public Response&lt;String> ping() { return Response.success("pong"); } 标识了 @RequestMapping 注解的方法会被 SpringMVC 框架的 RequestMappingHandlerMapping 类在启动时进行扫描并根据映射信息来创建 RequestMappingInfo(RequestMappingInfo 类维护请求的映射信息)，扫描后的所有Mapping信息在 MappingRegistry(AbstractHandlerMethodMapping内部类) 类进行维护
SpringMVC如何处理request与HandlerMethod的映射关系 AbstractHandlerMethodMapping的getHandler 方法用来通过给定的request来找到一个合适的handler进行处理 getHandler会先调用抽象方法 getHandlerInternal 由子类实现查找逻辑，如果找不到，则查找默认配置的Hanlder，默认Hanlder找不到则返回null
SpringMVC默认使用了哪些HandlerMapping 如何查询Handler是在 DispacherServlet的getHandler方法操作的，它会在所有的handlerMappings(有序handlerMapping)中查找出一个可用的handler进行request的处理 如图可知会在7个handlerMapping中依次进行查询，这些handlerMapping是在 DispatcherServlet#initHandlerMappings() 设置的
定位到问题原因 跟踪请求代码发现对于不存在的url会在 SimpleUrlHanlderMapping中找到可用的handler，因为最终请求url匹配上了 /**，而 /** 模式对应的handler就是 ResourceHttpRequestHandler，此时getHandler的结果就是ResourceHttpRequestHandler 了，但是在上报时使用的是 HandlerMethod，执行到此时报了转换异常
WebMvcAutoConfiguration中的SourceHandler在哪注册的？ 在启用MVC功能时，会增加注解 @EnableWebMvc，而对应的MVC配置类为 WebMvcConfigurationSupport，在这个类中进行SourceHandler的注册。跟踪代码发现两个ResourceHandler是在 WebMvcAutoConfigurationAdapter中添加的
...</p></div><footer class=entry-footer><span title='2025-04-18 11:27:45 +0800 CST'>April 18, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>72 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC学习之HandlerMapping" href=http://blog.imcompany.cn/post/spring-webmvc-handler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC学习之Exception处理</h2></header><div class=entry-content><p>背景 开发过程中，会出现很多异常情况，比如RPC调用异常、请求参数异常，SpringMVC是如何处理异常信息的?
Spring处理异常的方式 Spring采用了全局的异常捕获统一处理的方式，虽然JAVA的异常机制一直有争议，但是Spring还是选择基于实际开发需要使用抛异常后捕获统一处理的方式
HandlerExceptionResolver登场 HandlerExceptionResolver 是SpringMVC提供的解析Handler调用过程抛出异常的解析器，只提供了一个解析异常的方法 resovleException
Spring提供了哪些ExceptionResolver? 经典的Interface-Abstract方式的实现类 Resolver Desc SimpleMappingExceptionResolver 提供exception class name到view的映射 DefaultHandlerExceptionResolver 默认Resolver实现，用于解析标准的SpringMVC异常并转换成对应的Http状态码 ResponseStatusExceptionResolver 基于 @ResponseStatus 注解来映射异常与Http状态码 ExceptionHandlerExceptionResolver 基于 @ExceptionHalder 注解来解析处理异常信息 直接实现HandlerExceptionResolver的类 Resolver Desc DefaultErrorAttributes 默认错误属性实现 HandlerExceptionResolverComposite 代理其它Resolver集合的ExceptionResolver HandlerExceptionResolverComposite 中包含了一个解析列表，可以判断是会排序后顺序调用，以找到第一个可以处理的Resolver
具体异常处理流程 异常处理的核心逻辑都在 processHandlerException 方法中，Spring处理完请求后，如果有异常抛出，则会把异常信息传给 processHandlerException 方法， processHandlerException 遍历持有的 handlerExceptionResolvers 进行对异常的解析，如果解析成功则直接返回对应的 ModelAndView(此返回与正常的handler处理返回保持了一致)
handlerExceptionResolvers 有哪些？ 在 SpringMVC启动时会调用 initHandlerExceptionResolvers 方法来查找所有可用的 handlerExceptionResolver 并保存到 handlerExceptionResolvers 变量中。SpringMVC配置了两个 resolver 来提供异常解析
errorAttributes 此Resolver是在 ErrorMvcAutoConfiguration 进行实例化的 此实现的 resolverExcption 方法逻辑简单，直接返回了null，不是关注重点
handlerExceptionResolver 此Resolver真正的实现类为 HandlerExceptionResolverComposite ，也就是持有多个ExceptionResolver列表的 Resolver，它是在 WebMvcConfigurationSupport 实例化的
...</p></div><footer class=entry-footer><span title='2025-04-14 11:04:00 +0800 CST'>April 14, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>139 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC学习之Exception处理" href=http://blog.imcompany.cn/post/spring-webmvc-exception/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringMVC统一配置接口WebMvcConfigurer功能</h2></header><div class=entry-content><p>接口说明 WebMvcConfigurer是Spring提供的统一配置接口，用于自定义Spring MVC的配置，全局更改服务的行为，提供的可配置项： 方法名称 参数 用途 addArgumentResolvers(List&lt;HandlerMethodArgumentResolver> argumentResolvers) List&lt;HandlerMethodArgumentResolver> argumentResolvers 添加自定义的 HandlerMethodArgumentResolver 用于解析方法参数。 addCorsMappings(CorsRegistry registry) CorsRegistry registry 配置跨域资源共享 (CORS) addFormatters(FormatterRegistry registry) FormatterRegistry registry 添加自定义的格式化程序和转换器 addInterceptors(InterceptorRegistry registry) InterceptorRegistry registry 添加自定义的拦截器 addRequestMappings(RequestMappingInfo customization, Class&lt;Controller> controllerClass) RequestMappingInfo customization, Class&lt;Controller> controllerClass 关联自定义请求映射到具控制器类 addResourceHandlers(ResourceHandlerRegistry registry) ResourceHandlerRegistry registry 配置资源处理，如静态资源路径 addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler> returnValueHandlers) List&lt;HandlerMethodReturnValueHandler> returnValueHandlers 添加自定义的 HandlerMethodReturnValueHandler 用于处理方法返回值 addViewControllers(ViewControllerRegistry registry) ViewControllerRegistry registry 注册视图控制器 configureAsyncSupport(AsyncSupportConfigurer configurer) AsyncSupportConfigurer configurer 配置异步支持 configureContentNegotiation(ContentNegotiationConfigurer configurer) ContentNegotiationConfigurer configurer 配置内容协商策略 configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) DefaultServletHandlerConfigurer configurer 启用默认 Servlet 处理 configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver> exceptionResolvers) List&lt;HandlerExceptionResolver> exceptionResolvers 配置异常处理程序 configureMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) List&lt;HttpMessageConverter&lt;?>> converters 配置自定义的 HttpMessageConverter configurePathMatch(PathMatchConfigurer configurer) PathMatchConfigurer configurer 配置路径匹配规则 configureViewResolvers(ViewResolverRegistry registry) ViewResolverRegistry registry 配置视图解析器 extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver> exceptionResolvers) List&lt;HandlerExceptionResolver> exceptionResolvers 扩展异常处理程序 extendMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) List&lt;HttpMessageConverter&lt;?>> converters 扩展自定义的 HttpMessageConverter extendInterceptors(List&lt;HandlerInterceptor> interceptors) List&lt;HandlerInterceptor> interceptors 扩展拦截器 extendArgumentResolvers(List&lt;HandlerMethodArgumentResolver> argumentResolvers) List&lt;HandlerMethodArgumentResolver> argumentResolvers 扩展自定义的 HandlerMethodArgumentResolver 用于解析方法参数。 extendReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler> returnValueHandlers) List&lt;HandlerMethodReturnValueHandler> returnValueHandlers 扩展自定义的 HandlerMethodReturnValueHandler 用于处理方法返回值。 extendViewResolvers(List&lt;ViewResolver> viewResolvers) List&lt;ViewResolver> viewResolvers 扩展视图解析器 关联类 WebMvcConfigurationSupport EnableWebMvc 接口常用方法 接口提供了将近20个方法对Spring的配置进行调整，本次只针对常用的Rest接口开发相关内容进行展开学习研究
...</p></div><footer class=entry-footer><span title='2025-03-28 18:18:10 +0800 CST'>March 28, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>461 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to SpringMVC统一配置接口WebMvcConfigurer功能" href=http://blog.imcompany.cn/post/spring-webmvcconfigurer/></a></article></main><footer class=footer><span>&copy; 2026 <a href=http://blog.imcompany.cn/>I'm company</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>