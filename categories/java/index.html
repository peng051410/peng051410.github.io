<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | I'm company</title><meta name=keywords content><meta name=description content="Everyone is a company."><meta name=author content="Me"><link rel=canonical href=http://blog.imcompany.cn/categories/java/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://blog.imcompany.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.imcompany.cn/categories/java/index.xml title=rss><link rel=alternate hreflang=en href=http://blog.imcompany.cn/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://blog.imcompany.cn/categories/java/"><meta property="og:site_name" content="I'm company"><meta property="og:title" content="Java"><meta property="og:description" content="Everyone is a company."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.imcompany.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java"><meta name=twitter:description content="Everyone is a company."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://blog.imcompany.cn/ accesskey=h title="Home (Alt + H)"><img src=http://blog.imcompany.cn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.imcompany.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.imcompany.cn/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://blog.imcompany.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/peng051410/today_i_learn title=Til><span>Til</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://blog.imcompany.cn/>Home</a>&nbsp;»&nbsp;<a href=http://blog.imcompany.cn/categories/>Categories</a></div><h1>Java
<a href=/categories/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JAVA中如何判断对象与类的关系之-instanceOf, Class.isInstance, Class.isAssignableFrom</h2></header><div class=entry-content><p>前言 在开发中，常常会碰到检查JAVA对象是不是指定类型的情况，在JAVA中提供了以下几种方法实现此类需求:
instanceOf Class.isInstance() Class.isAssignbleFrom() 今天对此三种实现进行具体学习，以加深理解并更好的使用
准备工作 先创建一个名为 Shape 的接口，一个实现了 Shape 接口的类 Triangle , 再定义一个继承 Triangle 类的类 IsoscelesTriangle
public interface Shape { } public class Triangle implements Shape { } public class IsoscelesTriangle extends Triangle { } 以上三个类的类图关系如下 instanceOf instanceOf 是JAVA中的一个关键字，用于判断 实例对象是否是指定类型的子类型 ，常用于类型转换(cast)之前进行判断，操作的元素是一个对象和一个类型
Shape shape = new Triangle(); Triangle triangle = new Triangle(); IsoscelesTriangle isoscelesTriangle = new IsoscelesTriangle(); Shape nonspecificShape = null; assertTrue(shape instanceof Shape); assertTrue(triangle instanceof Shape); assertTrue(isoscelesTriangle instanceof Shape); assertFalse(nonspecificShape instanceof Shape); assertTrue(shape instanceof Triangle); assertTrue(triangle instanceof Triangle); assertTrue(isoscelesTriangle instanceof Triangle); assertFalse(nonspecificShape instanceof Triangle); assertFalse(shape instanceof IsoscelesTriangle); assertFalse(triangle instanceof IsoscelesTriangle); assertTrue(isoscelesTriangle instanceof IsoscelesTriangle); assertFalse(nonspecificShape instanceof IsoscelesTriangle); 上面例子测试 instanceOf 左侧对象是否是右侧类型的实例类型
...</p></div><footer class=entry-footer><span title='2022-12-12 19:14:00 +0800 CST'>December 12, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>249 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to JAVA中如何判断对象与类的关系之-instanceOf, Class.isInstance, Class.isAssignableFrom" href=http://blog.imcompany.cn/post/java-check-object-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Springwebflux源码学习-服务启动流程</h2></header><div class=entry-content><p>学习目标 理解WebFlux核心组件HttpHandler、WebHandler的创建过程 理解DispatcherHandler如何映射请求url及参数的过程 理解Netty服务的主要启动节点 此次学习的Spring boot版本为2.6.6，对应的Spring webflux版本为5.3.18
入口 Springboot工程入口方法为 SpringApplication.run() ，从此方法开始进行分析。
public static void main(String[] args) { SpringApplication.run(Main.class, args); } 决定启动的web应用类型 整个服务的web应用类型是在构造 SpringApplication 类时进行确定的，具体代码如下：
this.webApplicationType = WebApplicationType.deduceFromClasspath(); 判断应用类型的逻辑 org.springframework.web.reactive.DispatcherHandler存在 org.springframework.web.servlet.DispatcherServlet不存在 org.glassfish.jersey.servlet.ServletContainer不存在 即确认webApplicationType为 Reactive
if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } 创建具体的ApplicationContext 根据webApplicationType(Reactive)确定创建的ApplicationContext为AnnotationConfigReactiveWebServerApplicationContext，此Context支持 @Component 和 JSR-330规范中 @Inject 形式的依赖注解
SpringAplication.createApplicationContext() switch (webApplicationType) { case SERVLET: return new AnnotationConfigServletWebServerApplicationContext(); case REACTIVE: return new AnnotationConfigReactiveWebServerApplicationContext(); default: return new AnnotationConfigApplicationContext(); } 最主要的ApplicationContext.refresh()方法 refresh的Refresh阶段 刷新操作是在 AbstractApplicationContext 类的refresh方法中进行，在调用invokeBeanFactoryPostProcessors方法时会有对controller注解的扫描与处理
...</p></div><footer class=entry-footer><span title='2022-05-24 17:37:00 +0800 CST'>May 24, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>351 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to Springwebflux源码学习-服务启动流程" href=http://blog.imcompany.cn/post/springwebflux-start/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>记一次SpringWebflux框架下堆外OOM排查经历</h2></header><div class=entry-content><p>症状 生产环境业务页面打不开，看错误日志是 OutOfDirectMemoryError (OOM)了，详情报错信息如下：
2022-03-21 06:00:00.541 [,] [tafprx-asyrecv_9] ERROR r.c.p.Operators - [error,314] - Operator called default onErrorDropped java.lang.OutOfMemoryError: Direct buffer memory at java.base/java.nio.Bits.reserveMemory(Bits.java:175) at java.base/java.nio.DirectByteBuffer.&lt;init>(DirectByteBuffer.java:118) at java.base/java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:317) at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:632) at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:607) at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:202) at io.netty.buffer.PoolArena.tcacheAllocateSmall(PoolArena.java:172) at io.netty.buffer.PoolArena.allocate(PoolArena.java:134) at io.netty.buffer.PoolArena.allocate(PoolArena.java:126) at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:395) at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187) at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178) at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115) at org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:71) at org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:39) at org.springframework.http.codec.json.AbstractJackson2Encoder.encodeValue(AbstractJackson2Encoder.java:236) at org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$0(AbstractJackson2Encoder.java:150) at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:113) at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) at reactor.core.publisher.MonoCompletionStage.lambda$subscribe$0(MonoCompletionStage.java:82) at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2251) at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:143) at reactor.core.publisher.MonoCompletionStage.subscribe(MonoCompletionStage.java:57) at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:249) at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.complete(MonoIgnoreThen.java:284) at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onNext(MonoIgnoreThen.java:187) at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) 根据报错的堆栈，找到 AbstractJackson2Encoder:236 行，调试发现框架使用的buffer在最后都进行了释放，看着没问题。
...</p></div><footer class=entry-footer><span title='2022-03-31 20:12:23 +0800 CST'>March 31, 2022</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>615 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 记一次SpringWebflux框架下堆外OOM排查经历" href=http://blog.imcompany.cn/post/springwebflux-leak-bug/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>让好代码生生不息-更好的使用String</h2></header><div class=entry-content><p>开发中常用的String操作 开发中经常用到的操作有：
格式化/日志格式化 字符串判断 字符串处理，常见的如处理字符串的第一个/最后一个字符 String.format String.format()是一个格式化的方法，使用%为前缀来表示要格式化的内容占位，一般的使用方法为：
String.format("test result is %s", "success"); 但是当要格式化的占位符与参数个数不同时会发生什么呢？
占位符个数与参数个数相同 如上代码，可以正常进行输出: test result is success
占位符个数少于参数个数 String.format("test result is %s", "success", "other"); 可以正常打印，输出结果为: test result is success
占位符个数多于参数个数 String.format("test result is %s %s %s", "success", "other"); 抛出了异常java.util.MissingFormatArgumentException: Format specifier ‘%s’
问题总结 为什么占位符数少于参数个数可以正常执行，而多于参数个数却报了异常？看JAVADOC发现，如果占位符个数少于参数个数，则多余的参数被忽略，如果多于参数个数，则在进行解析时会判断待处理占位符位置与参数个数，主要代码逻辑如下：
if (args != null && lasto > args.length - 1) throw new MissingFormatArgumentException(fs.toString()); 所以在使用String.format方法 切记 要参数个数多于待解析占位符的个数，这种问题常因为Copy操作后，处理了部分参数而忘记对应处理占位符
替换方案
目前看到很多的老代码打印日志时大都使用String.format()，可以改成slf4j的{} 还可以使用Apache common utils中的StringUtils.joinWith()或者Google guava的Joiner连接器 Apache commons utils-StringUtils 在StringUtils中有一个isNumeric方法，用来判断字符串是不是数字，那下面的代码会返回什么呢？
...</p></div><footer class=entry-footer><span title='2021-08-23 14:04:09 +0800 CST'>August 23, 2021</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>221 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 让好代码生生不息-更好的使用String" href=http://blog.imcompany.cn/post/best-code-string/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>让好代码生生不息-更好的对待NULL</h2></header><div class=entry-content><p>什么样的代码是好代码 易读的代码，行云流水的代码
JAVA中的NULL处理 众所周知，在Java代码中总是少不了一堆的判null逻辑，在代码bug中，NullPointerException出镜率也是非常高的，尤其是现在的主流分布式架构，一个web接口要调用后端的N个RPC服务来实现功能，基于防御编程的思想，判null就更重要了
在处理NULL时怎么做更好 IDE 既然无法避免null，IDE就给程序员增加了可以快速判断空的功能，比如在IDEA中，可以使用Postfix功能，在对象上o使用.nn来快速输入if(o != null) {}
JAVA基础类库 近期的JDK版本也针对null判断增加了一些实用的方法
Objects类 JAVA8在Objects工具提供了isNull()和nonNull()方法，JAVA9又增加了requireNonNullElse()和requireNonNullElseGet()来给待处理对象增加设置默认值的方法
知名三方库 Apache common utils中提供了非常多的判空工具类，如针对String操作的StringUtils类和针对集合操作的CollectionUtils、MapUtils、ListUtils、SetUtils，这几个类都有一些典型的方法来进行判空处理，通用的方法如下：
StringUtils isEmpty()/isNotEmpty()
判断String是否为空/不空
isBlank()/isNoneBlank()
判断String是否为空/不空，这类方法还会判断实际值是否为空串
defaultString()
此方法允许在String为null时为返回空串
defaultIfBlank()/defaultIfEmpty()
此方法允许在String为空串或null时设置一个默认值
集合类Utils isEmpty()/isNotEmpty()
判断集合是否为空/不空
emptyIfNull()
这是一个很有用的方法，当传入对象为空时则返回设置的默认对象，可以很好的根治if处理null的问题，下面两段代码演示一下
正常情况下有if判断 List&lt;Object> values = rpcClient.getFromRpcList(); if(CollectionUtils.isNotEmpty(values)) { return values .forEach(System.out::println); } 使用emptyIfNull方法 return CollectionUtils.emptyIfNull(rpcClient.getFromRpcList()) .forEach(System.out::println); 这样保证了代码编写的连贯性，爽！
此方法在ListUtis、MapUtils、SetUtils中也有提供
defaultIfNull()
此方法允许在集合为null时设置一个默认值，也是可以链式操作
优秀的Coder 在编写通用方法时，对于有null返回的情况可以使用返回默认值来代替null
不返回空，以空对象来代替 比如返回一个new Object()
...</p></div><footer class=entry-footer><span title='2021-07-17 16:04:09 +0800 CST'>July 17, 2021</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>60 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 让好代码生生不息-更好的对待NULL" href=http://blog.imcompany.cn/post/best-code1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JAVA8问题处理回顾-持续更新</h2></header><div class=entry-content><p>金额累加问题 使用Reduce进行累加操作，参考这里
List&lt;BigDecimal> bdList = new ArrayList&lt;>(); //populate list BigDecimal result = bdList.stream().reduce(BigDecimal.ZERO, BigDecimal::add); 查找集合的最后一个元素 JAVA8的Stream只提供了FindFirst功能，没有FindLast功能，可以使用Reduce来实现查找最后一个元素的效果
import java.util.*; import java.util.stream.*; public class GetLastEleFromCollection { public static void main(String[] args) { List&lt;String> list = new ArrayList&lt;>(); list.add("aaa"); list.add("idddd"); list.add("bbbb"); String lastElement = list.stream() .reduce((first, second) -> second) .orElse(null); System.out.println(lastElement); } } bbbb 比较两个时间是否是同一天 import java.time.*; import java.time.temporal.*; public class CompareDay { public static void main(String[] args) { final LocalDateTime now = LocalDateTime.now(); final LocalDateTime localDateTime = LocalDateTime.of(2019, 9, 29, 0, 0, 0); System.out.println(localDateTime.truncatedTo(ChronoUnit.DAYS).isEqual(now.truncatedTo(ChronoUnit.DAYS))); } } true 实现与Python的zip函数功能 import java.util.*; import java.util.function.*; public class Zip { public static void main(String[] args) { List&lt;List&lt;Integer>> result = handle(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), (i, j) -> Arrays.asList(i, j)); System.out.println(result); } public static &lt;T, U, R> List&lt;R> handle(List&lt;T> list, List&lt;U> list1, BiFunction&lt;T, U, R> biFunction) { List&lt;R> result = new ArrayList&lt;>(); for(int i = 0; i &lt; list.size(); i ++) { result.add(biFunction.apply(list.get(i), list1.get(i))); } return result; } } [[1 (\, 4)] (\, [2 (\, 5)]) (\, [3 (\, 6)])] 多个Predicate链 import java.util.*; import java.util.stream.*; import java.util.function.*; public class MorePredicate { public static void main(String[] args) { List&lt;Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6); final Predicate&lt;Integer> predicate = i -> i % 2 == 0; final Predicate&lt;Integer> predicate1 = predicate.and(integer -> integer > 5); List&lt;Integer> result = list.stream() .filter(predicate1) .collect(Collectors.toList()); System.out.println(result); } } [6]</p></div><footer class=entry-footer><span title='2019-08-24 10:15:55 +0800 CST'>August 24, 2019</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>220 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to JAVA8问题处理回顾-持续更新" href=http://blog.imcompany.cn/post/java8-issue-review/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之代理模式</h2></header><div class=entry-content><p>说明 代理模式是设计模式中使用频率非常的高的模式，像日常生活中的房产中介、外卖平台都属于代理。代理模式就是在访问真正的业务之时不会直接与真正的业务进行调用，而是与一个与真正业务对象有着相同功能声明的代理来进行处理，但是最终的处理还是由真正的业务类来进行（决定），比如房产中介，他们会帮助找房者根据条件来对可选房屋进行筛选，但是最终订与不订的权利还是由找房者来决定。常见的代理有保护代理、虚拟代理、远程代理。
代理模式 我们常用的后台系统一般会根据用户权限的不同对用户展示不同的业务菜单，拥有高权限的人会展示相对多的菜单进行操作，在这个过程中还要记录用户的操作日志，用户点了什么，执行了什么操作都需要进行记录，达到有据可查。在这个业务场景下，就可以使用代理模式进行实现。代理对象会持有一个真正业务对象的实例，在代理对象中还引用日志服务与权限服务，所有的请求都经过这个代理类来进行，这样就可以根据操作的用户的状态来进行相应的处理了。具体的代码实现如下：
定义一个查询接口，在这里定义一个查询用户收入的方法，如下: package cn.imcompany.proxy; /** * Created by tomyli on 2018/6/28. * Github: https://github.com/peng051410 */ public interface Search { void queryIncome(String username); } 再定义一个实现该接口的具体业务类： package cn.imcompany.proxy; /** * Created by tomyli on 2018/6/28. * Github: https://github.com/peng051410 */ public class SearchService implements Search { @Override public void queryIncome(String username) { System.out.println(username + "开始查询"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(username + "查询完成"); } } 在上面代码中就实现了查询收入的方法，简单的打印了两行日志。
...</p></div><footer class=entry-footer><span title='2018-07-16 21:08:28 +0800 CST'>July 16, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>189 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之代理模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-dai-li-mo-shi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之委托模式</h2></header><div class=entry-content><p>说明 委托模式不属于23种设计模式中，但是它在Spring框架中使用的很频繁，Spring的作用在Java的开发是非常大，所以需要学习一下委托模式。委托模式是指两个对象都有相同的方法与功能，比如A、B两个对象都有相同的方法，但是有调用A的method方法，A不会自己来处理而是直接调用了B的同名方法，由两个对象参与同一个请求，接受请求的对象将委托给另一个对象来处理。
委托模式 在一般的公司中，都会分为老板、项目经理、开发人员结构，老板负责制定决策，分配给项目经理后，他不会自己来完成，而是把需要的功能进行分解，交给擅长的开发人员进行实现。虽然项目经理也可以完成，但是是他把这些事情委托给了多个开发人员来做，加快了完成任务的速度。就以这个需求来说，使用委托模式来进行实现:
定义抽象的人类接口：
package cn.imcompany.delegate; /** * Created by tomyli on 2018/6/27. * Github: https://github.com/peng051410 */ public interface Member { void showName(); void showSkill(); void doWork(); } 上面代码中定义了抽象的人类接口，显示这个人的名字，拥有的技能，工作的状态情况，接下来实现需求中的每个人。
定义老板(BOSS):
package cn.imcompany.delegate; /** * Created by tomyli on 2018/6/27. * Github: https://github.com/peng051410 */ public class Boss implements Member { @Override public void showName() { System.out.println("i am boss"); } @Override public void showSkill() { System.out.println("send commend"); } @Override public void doWork() { } } 定义项目经理和员工:
...</p></div><footer class=entry-footer><span title='2018-07-07 18:53:57 +0800 CST'>July 7, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>282 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之委托模式" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-wei-tuo-mo-shi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之观察者</h2></header><div class=entry-content><p>说明 观察者模式在日常开发中使用频率也是非常高的，它建立了对象与对象之间的关系，一个对象的行为改变会通知到另一个对象，被通知的对象根据通知做出相应的处理动作。在观察者中分为目标对象（被观察者）、观察者。观察者模式是一种对象行为模式。
观察者模式 现在很多人都购买股票，在市面上有很多的股票软件供广大股民使用。股票软件一般会在用户关注的股票有变动时发送消息来通知股民。在这里，某一支股票就是目标对象，广大股民与股票软件就是观察者，他们根据股票的行情变化来做出相应买入或者卖出操作。这一需求可以使用观察者模式进行实现。代码如下：
先来定义一个抽象的购买股票的股民们，他们有喜有悲的心情:
package cn.imcompany.observer.stock; /** * Created by tomyli on 2018/6/23. * Github: https://github.com/peng051410 */ public interface Buyer { void setName(String name); String getName(); void happy(); void sad(); } 再来定义具体的股民行为实现类：
package cn.imcompany.observer.stock; /** * Created by tomyli on 2018/6/23. * Github: https://github.com/peng051410 */ public class ConcrectBuyer implements Buyer { private String name; @Override public void setName(String name) { this.name = name; } @Override public String getName() { return name; } @Override public void happy() { System.out.println(this.getName() + ":happy"); } @Override public void sad() { System.out.println(this.getName() + ":sad"); } } 具体的股民实现了喜与悲的方法，这样观察者已经准备就绪。下面来定义股票软件：
...</p></div><footer class=entry-footer><span title='2018-07-04 20:31:41 +0800 CST'>July 4, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>244 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之观察者" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-guan-cha-zhe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式学习之装饰器</h2></header><div class=entry-content><p>说明 装饰器设计模式是使用比较频繁的设计模式，它在不改变原物体的情况对原物体实现了功能的增加，原物体还是一个可单独使用的个体。在JAVA的类库中应该会马上想到IO类，各种的InputStrem，OutputStrem。
装饰器模式 在用户登录的中过程，我们需要对用户输入的密码进行加密操作，在设计时会提供好多种加密的算法，例如简单的BASE64加密，复杂的如MD5、DSA加密。直接把用户的密码存入数据库是真的在耍流氓。在使用这些算法时，我们想灵活的使用，比如使用完简单加密还可以再进行一下MD5的加密。针对这样的需求，可以使用装饰器模式进行实现。大体思路如下：
加密接口，定义加密方法。 在装饰器中，最原始的被装饰者是目标实现，它们一般会实现加密定义的具体方法。 装饰者会针对目标对象进行装饰，所以它要同样实现加密接口的方法，一般情况下这个装饰器会定义为抽象的形式，在这个装饰器父类中维护着对目标对象的引用。 具体装饰器继承抽象装饰器来实现对目标对象的真正装饰操作。 以上的情况在代码上体现为如下形式：
加密接口 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public interface Encryptor { void encrypt(); } 具体加密类，实现加密处理接口 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public class ConcreteEncryptor implements Encryptor { @Override public void encrypt() { System.out.println("base encrypt!"); } } 抽象加密装饰器 package cn.imcompany.decorator.encrypt; /** * Created by tomyli on 2018/6/25. * Github: https://github.com/peng051410 */ public abstract class EncryptDecorator implements Encryptor { private Encryptor encrypt; public EncryptDecorator(Encryptor encrypt) { this.encrypt = encrypt; } @Override public void encrypt() { encrypt.encrypt(); } } 上面的抽象装饰器实现的加密接口，在这个类中维护加密接口的实体，加密方法直接调用其维护实体的加密方法。
...</p></div><footer class=entry-footer><span title='2018-07-02 20:09:14 +0800 CST'>July 2, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>236 words</span>&nbsp;·&nbsp;<span>tomyli</span></footer><a class=entry-link aria-label="post link to 设计模式学习之装饰器" href=http://blog.imcompany.cn/post/she-ji-mo-shi-xue-xi-zhi-zhuang-shi-qi/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://blog.imcompany.cn/categories/java/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=http://blog.imcompany.cn/>I'm company</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>